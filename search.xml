<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C语言基础]]></title>
    <url>%2F2019%2F05%2F07%2FC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[二维数组与指针二维数组的定义类型 数组名[常量表达式1][常量表达式2]; 例如：float a[2][3]; 二维数组的引用数组名[行下标][列下标]; 二维数组的初始化1、分行初始化12345int a[3][4] = &#123; &#123;1,2,3,4&#125;, &#123;5,6,7,8&#125;, &#123;9,10,11,12&#125;&#125;; 2、按顺序初始化1int a[3][4] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; 3、部分元素初始化12345int a[3][4] = &#123; &#123; ,1&#125;, &#123;0,6&#125;, &#123;0,0,11&#125;&#125;; 1230 1 0 00 6 0 00 0 11 0 4、如果对全部元素赋值，定义数组可以不指定一维长度1int a[][4] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; 二维数组的输入与输出二维数组的输入与输出是通过对每个元素的输入输出实现的。 1、输入方法123for(int i = 0; i &lt; 2; i++) for(int j = 0; j &lt; 3; j++) scanf(&quot;%d&quot;,&amp;a[i][j]); 2、输出方法123for(int i = 0; i &lt; 2; i++) for(int j = 0; j &lt; 3; j++) printf(&quot;%d&quot;,a[i][j]); 指向二维数组的指针二维数组可以堪称时由多个一维数组的组合。 比如：对于int a[3][4];(1)a是数组名，包含三个元素，a[0],a[1],a[2]。(2)每个元素a[i]又是一个一维数组，包含4个元素。 二维数组的行指针与列指针 例子 类型 意义 a 行指针类型 二维数组的首地址，第0行的地址 a+i 行指针类型 第i行的地址 *(a+i) 列指针类型 第i行第0列的地址 *(a+i)+j 列指针类型 第i行第j列的地址 ((a+i)+j) 元素 第i行第j列的元素 指针与二维数组1、列指针12345678int *p;int a[3][4];p = a[0]; //用列地址初始化int i,j;for(i = 0; i &lt; iMAX; i++) for(j = 0; j &lt; jMAX; j++) printf(&quot;%d&quot;,*(p+i*n+j)); //或p[i*n+j] 2、行指针1234567int (*p)[3]; //行指针，指向数组的一行p = a; //用行指针初始化int i,j;for(i = 0; i &lt; iMAX; i++) for(j = 0; j &lt; jMAX; j++) printf(&quot;%d&quot;,*(*(p+i)+j)); //可以写成p[i][j] 特殊的指针：数组类型指针例如：int (*iPtr)[3]; 类型名：”int”说明其指向的数组变量类型是整型。数组类型指针变量名：”iPtr”说明要定义的变量名字。整型常量表达式：”3”说明指向的数组变量元素个数为3。 指针数组元素均为指针类型数据的数组，称为指针数组定义形式：类型关键字 *数组名[数组长度];例如：char *pStr[5]; 12345678//二维字符数组void main()&#123; int i; char str[][10] = &#123;&quot;Pascal&quot;,&quot;Basic&quot;,&quot;Fortran&quot;,&quot;Java&quot;,&quot;VisualC&quot;&#125;; for(i = 0; i &lt; 5; i++) printf(&quot;%s\n&quot;,str[i]);&#125; 12345678//字符指针数组void main()&#123; int i; char *ptr[] = &#123;&quot;Pascal&quot;,&quot;Basic&quot;,&quot;Fortran&quot;,&quot;Java&quot;,&quot;VisualC&quot;&#125;; for(i = 0; i &lt; 5; i++) printf(&quot;%s\n&quot;,ptr[i]);&#125; 命令行参数int main(int argc, char* argv[]) 动态分配内存1234567891011121314#include&lt;stdlib.h&gt;void* malloc(unsigned int size);//向系统申请大小为size的内存块，返回首地址。申请不成功返回NULL。void* calloc(unsigned int num, unsigned int size);//向系统申请num个size大小的内存块，返回首地址。申请不成功返回NULL。void free(void* p);//释放由malloc和calloc申请的内存块。p是指针。//例如：if(p == NULL)&#123;free(p); p = NULL&#125;void* realloc(void* pointer, unsigned int size);//如果重新分配成功，返回指向被分配内存的指针，否则返回空指针NULL。 结构体结构体的定义一般形式：12345struct 结构体名&#123; 类型关键字 成员名1; 类型关键字 成员名2; 类型关键字 成员名3;&#125;; 例如：12345struct student&#123; int ID; char name[20]; int age;&#125;; 结构体只是定义了数据的形式，未生成任何变量，可以如下定义：struct student stu;。 定义类型名12345typedef struct student&#123; int ID; char name[20]; int age;&#125;STUD; 或直接typedef struct student STUD;。 定义的类型名就与普通数据形式一样的使用方法。 链表类型：12345struct student&#123; int ID; struct student* next;&#125;;typedef struct student Node; 尾插法创建链表基本思路：1、申请一个节点的空间，置指针域为空。2、输入结点数据域的数据。3、搜索链表的最后一个结点。4、将新结点插入到链表尾。5、返回头指针。 12345678910111213141516171819202122232425Node* Add_end(Node* head)&#123; Node *p; Node *tail; p = (Node*)malloc(sizeof(Node)); if(NULL == p)&#123; printf(&quot;Wrong!&quot;); exit(1); &#125; p-&gt;next = NULL; scanf(&quot;%d&quot;,&amp;(p-&gt;ID) ); //一个结点创建完毕。 if(NULL == head)&#123; head = p; &#125; else&#123; tail = head; while(tail-&gt;next != NULL)&#123; tail = tail-&gt;next; &#125; //找到尾节点 tail-&gt;next = p; //插入 &#125; return head; //返回&#125; 头插法创建链表基本思路：1、建立空链表，但不需要定义尾指针。2、生成新结点，对新结点赋值，指针域可不必赋值。3、将结点插入到链表中。 12345678910111213141516Node* Add_head(Node* head)&#123; Node* p; p = (Node*)malloc(sizeof(Node)); if(NULL == p)&#123; printf(&quot;Wrong!&quot;); exit(1); &#125; p-&gt;next = NULL; scanf(&quot;%d&quot;,&amp;(p-&gt;ID)); //单个结点创建完成 p-&gt;next = head; head = p; //插入完成 return head;&#125; 文件操作打开文件fopen常用的打开文件方法：1234if( (fp = fopen(&quot;文件名&quot;,&quot;操作方式&quot;)) == NULL )&#123; printf(&quot;打不开文件\n&quot;); exit(1);&#125; 文件操作方式： 文件操作方式 含义 r(只读) 为输入打开一个文本文件 w(只写) 为输出打开一个文本文件 a(追加) 向文本文件尾增加数据 rb(只读) 为输入打开一个二进制文件 wb(只写) 为输出打开一个二进制文件 ab(追加) 向二进制文件尾增加数据 r+(读写) 为读/写打开一个文本文件 w+(读写) 为读/写建立一个新的文本文件 a+(读写) 为读/写打开一个文本文件 rb+(读写) 为读/写打开一个二进制文件 wb+(读写) 为读/写建立一个新的二进制文件 ab+(读写) 为读/写打开一个二进制文件 规律：1、含有”b”的为二进制文件操作。2、含有”+”的可以进行读写操作，且可以新建文件。 文件关闭fclose函数原型：int fclose(FILE *fp); 功能：关闭fp所指向的文件。 正常关闭返回0，出错返回非0值。 读/写文件中的一个字符写入一个字符到文件中——fputc函数原型：int fputc(int c, FILE *fp); 功能：把一字节代码c写入fp指向的文件中，同时读写位置指针指向下一个写入位置。 返回值：正常，返回c（ASCLL码）；错误返回EOF。 从文件中读取一个字符——fgetc函数原型：int fgetc(FILE *fp) 功能：从fp指向的文件中读取一字节代码。 返回值：正常，返回读到的代码值；读到文件为或出错，返回EOF。 库函数feof函数原型：int feof(FILE *fp) 功能：执行读文件操作时，遇到文件尾，返回逻辑真；否则返回0。 读/写一个字符串读一个字符串——fgets函数原型：char *fgets(char *s, int n, FILE *fp) 功能：从fp所指向文件读n-1个字符送股s指向的内存区，并在最后加一个’\0’。 返回值：正常时返回读取字符串的首地址；出错或遇文件尾返回NULL。 写一个字符串——fputs函数原型：int fputs(char *s, FILE *fp) 功能：把s指向的字符串写入fp指向的文件。 返回值：正常时返回写入的最后一个字符；出错为EOF。 读/写一个数据块读一个数据块——fread函数原型：int fread(void *buffer, int size, int count, FILE *fp) 功能：从fp所指向的文件的当前位置开始，一次读入size个字节，重复count次，并将读入的数据存放到从buffer开始的内存中；同时，将读写位置指针移动size*count个字节。 返回值：调用成功，返回count；否则为0。 注意：一般用于二进制文件的处理。 写一个数据块——fwrite函数原型：int fwrite(void buffer, int size, int count, FILE *fp) 功能：从buffer开始，一次输出size个字节，重复count次，并将输出的数据存放到fp所指向的文件中；同时将读写文件位置指针移动size*count个字节。 返回值：调用成功，返回count；否则为0。 注意：一般用于二进制文件的处理。 对文件进行格式化读写函数原型：1、读入：int fscanf(FILE *fp,const char*format,[argument,···])2、写出：int fprintf(FILE *fp,const char*format,[argument,···]) 功能：按格式对文件进行I/O操作。 返回值：成功，返回I/O的个数；出错或文件尾，返回EOF。 位置指针和文件定位位置指针复位函数——rewind函数原型：void rewind(FILE *fp) 功能：使文件的位置指针返回到文件头。 移动文件位置指针函数fseek函数原型：int fseek(FILE *fp, long int offset, int whence) 功能：将指定文件的位置指针，从参照点开始，移动指定的字节数。 参照点：’0’或SEEK_SET表示文件头，’1’或SEEK_CUR表示当前位置，’2’或SEEK_END表示文件尾。 返回值：成功为0；否则为非0值。 注意：一般用于二进制文件处理。 返回文件当前位置的函数ftell函数原型：long int ftell(FILE *fp) 功能：返回文件位置指针的当前位置（用相对于文件头的位移量表示）。如果返回值为-1L表明调用出错。 123offset = ftell(fp);if(offset == -1L) printf(&quot;ftell() error\n&quot;); 出错检测ferror函数函数原型：int ferror(FILE *fp) 功能：如果返回值为0，表示未出错；返回非0值，表示出错。 注意：(1)对同一文件，每次调用输入输出函数均产生新的ferror()函数值。因此调用的输入输出函数后，应立即检测，否则出错信息会丢失。(2)在执行fopen函数时，系统将ferror的值设为0。 clearerr函数函数原型：void clearerr(FILE *fp) 功能：将文件错误标志（ferror的值）和文件结束标志（feof的值）置为0。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础]]></title>
    <url>%2F2019%2F04%2F30%2FHTML%2F</url>
    <content type="text"><![CDATA[HTML初识HTML骨架格式1234567&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;html&gt; 标签解读：1、html标签：作用所有html中标签的一个根节点。2、head标签：用于存放：title（必须设置）、meta、base、style、script、link标签。3、title标签：页面的标题。4、body标签：页面主体部分，用于存放所有的标签。 HTML标签分类双标签1&lt;标签名&gt;内容&lt;/标签名&gt; 左边为开始标签，右边为结束标签，相对于开始标签多一个“/”结束符。 单标签&lt;标签名/&gt; 单标签也称空标签，一个标签即可完成相应功能。 1&lt;br /&gt; //换行标签 HTML标签关系嵌套关系123&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt; 并列关系12&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; sublime快速生成骨架1、html:52、!然后按下tab键即可生成HTML骨架。 文档类型&lt;!DOCTYPE&gt;1&lt;!DOCTYPE html&gt; 告诉我们使用哪个HTML版本。 这是HTML5的版本。 字符集简介（meta）1&lt;meta charset = &quot;UTF-8&quot;&gt; UTF-8是目前最常用的字符集编码方式，常用的字符集编码方式还有GBK和GB2312。 以后统统使用UTF-8的字符集。 HTML常用标签排版标签标题标签（熟记）单词缩写：head 为了使网页具有语义化，经常会在页面中用到标题标签，HTML提供了6个等级的标题 123&lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;和&lt;h6&gt;&lt;h1&gt;这是最大的标题&lt;/h1&gt; 注意：h1标签因为重要，尽量少用。一般都是给logo使用。 段落标签（熟记）单词缩写：paragraph 在网页中要把文字有条理地显示出来，离不开段落标签。 1&lt;p&gt;段落内容&lt;/p&gt; 默认情况下，文本在一个段落中会根据浏览器窗口地大小自动换行。 水平线标签（认识）单词缩写：horizontal 横线 在网页中常常看到一些水平线将段落与段落分开，使文档结构清晰，层次分明。 1&lt;hr /&gt; 单标签 在网页中显示默认样式水平线。 换行标签（熟记）单词缩写：break 打断，换行 在HTML中，一个段落中地文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，需要使用换行标签。 1&lt;br /&gt; 单标签 div和span标签（重点）单词缩写：division 分割，分区 span 跨度，范围 div和span是没有语义的，是我们网页布局主要的两个盒子。 文本格式化标签（熟记）在网页中，有时要为文字设置粗体、斜体或下划线效果，这是需要用到HTML中的文本格式化标签，使文字以特殊格式展现。 标签 显示效果 &lt;b&gt;&lt;/b&gt; &lt;strong&gt;&lt;/strong&gt; 文字以粗体的方式显示 &lt;i&gt;&lt;/i&gt;&lt;em&gt;&lt;/em&gt; 文字以斜体方式显示 &lt;s&gt;&lt;/s&gt;&lt;del&gt;&lt;/del&gt; 文字以加删除线方式显示 &lt;u&gt;&lt;/u&gt;&lt;ins&gt;&lt;/ins&gt; 文字以加下划线方式显示 strong、em、del、ins有强调语义的意思，推荐使用这四个标签。 1234567891011&lt;b&gt;我是粗体&lt;/b&gt; &lt;br /&gt;&lt;strong&gt;我是粗体，并强调语义&lt;/strong&gt; &lt;br /&gt;&lt;i&gt;我是斜体&lt;/i&gt; &lt;br /&gt;&lt;em&gt;我是斜体，并强调语义&lt;/em&gt; &lt;br /&gt;&lt;s&gt;我加删除线&lt;/s&gt; &lt;br /&gt;&lt;del&gt;我加删除线，并强调语义&lt;/del&gt; &lt;br /&gt;&lt;u&gt;我加下划线&lt;/u&gt; &lt;br /&gt;&lt;ins&gt;我加下划线，并强调语义&lt;/ins&gt; &lt;br /&gt; 标签属性使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置，其基本语法格式如下：1&lt;标签名 属性1 = &quot;属性值1&quot; 属性2 = &quot;属性值2&quot;&gt;文本内容&lt;/标签名&gt; 12要求：水平线的长度为500,颜色为红色。&lt;hr width = &quot;500&quot; color = &quot;red&quot; /&gt; 语法规则：1、标签可以有多个属性，必须写在开始标签之中，位于标签名之后。2、属性之间部分先后顺序，标签名与属性、属性与属性之间均已空格分开。3、任何标签的属性都有默认值省略该属性则取默认值。 图像标签img（重点）单词缩写：image 图像 1&lt;img src = &quot;图像URL&quot; /&gt; 单标签 该语法中src属性用于指定图像文件的路径和文件名，它是img标签的必须属性。 标记属性 属性 属性值 描述 src URL 图像的路径 alt 文本 图像不能显示时的替换文本 title 文本 鼠标悬停时显示的内容 width 像素（不支持%页面百分比） 设置图像的宽度 height 像素（不支持%页面百分比） 设置图像高度 border 数字 设置图像边框的宽度 1&lt;img src = &quot;#&quot; alt = &quot;替换文本&quot; title = &quot;悬停文本&quot; width = &quot;200&quot; border = &quot;10&quot; /&gt; 链接标签（重点）基本使用单词缩写：anchor 锚 在HTML中创建超链接非常简单，只需用标签环绕需要被链接的对象即可。 1&lt;a href = &quot;跳转目标&quot; target = &quot;目标窗口弹出方式&quot;&gt;文本或图像&lt;/a&gt; href：用于指定链接目标的URL地址。target：用于指定链接页面的打开方式，其取值（目前）有_self和_blank两种，_self为默认值，_blank为在新窗口中打开。（下划线不能省略） 注意：1、外部链接需要添加”http://“1&lt;a href = &quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; 2、内部链接直接链接内部页面名称即可。1&lt;a href = &quot;index.html&quot;&gt;首页&lt;/a&gt; 3、没有确定链接目标时，通常将href属性设为”#”。1&lt;a href = &quot;#&quot;&gt;不确定的网页&lt;/a&gt; 4、不仅可以创建文本链接，在网页中各种网页元素，如图像、表格、音频和视频等都可以添加超链接。 锚点链接（难点）通过创建锚点定位，用户可以快速定位到目标内容。如该博客的目录，点击相应内容，即可跳转至该位置。 创建锚点定位分两步：1、使用&lt;a href = &quot;#id&quot;&gt;链接文本&lt;/a&gt;创建链接文本。2、使用相应的id名标注跳转目标位置。 12&lt;a href = &quot;#live&quot;&gt;个人生活&lt;/a&gt;&lt;h3 id = &quot;live&quot;&gt;个人生活&lt;/h3&gt; base标签base可以设置整体链接的打开状态。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;base标签&lt;/title&gt; &lt;meta charset = &quot;UTF-8&quot; /&gt; &lt;base target = &quot;_blank&quot; /&gt; //页面中所有链接以新窗口打开 &lt;/head&gt; &lt;body&gt; &lt;a href = &quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;a href = &quot;http://www.sina.com&quot; target = &quot;_self&quot;&gt;新浪&lt;/a&gt; //当前窗口打开 &lt;a href = &quot;http://www.sohu.com&quot;&gt;搜狐&lt;/a&gt; &lt;a href = &quot;http://www.163.com&quot;&gt;网易&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 特殊字符标签（理解）有些特殊的符号无法直接显示在页面上，HTML为其编配了特殊字符编码。 注释标签如果需要在HTML文档里添加一些便于阅读和理解但又不需要显示在页面中的文字，就需要使用注释标签。 1&lt;!-- 注释语句 --&gt; 快捷键：ctrl+/ 注释内容不会显示在浏览器窗口中，但是作为HTML文档内容的一部分，会被下载到用户的计算机上，查看源码时就会看到。 路径（重点、难点）实际工作中，通常新建文件夹专门用来存放图像文件，这是插入图像文件就需要采用“路径”的方式来指定图像文件。 相对路径1、图像文件和HTML文件位于同一文件夹：只需要输入图像文件的名称即可。1&lt;img src = &quot;logo.gif&quot; /&gt; 2、图像文件位于HTML文件的下一级文件夹：输入文件夹名和文件名，之间用”/“隔开。1&lt;img src = &quot;img/logo.gif&quot; /&gt; 3、图像位于HTML文件的上一级文件夹：在文件名之前加入”../“,如果时上两级，则使用”../../“。1&lt;img src = &quot;../logo.gif&quot; /&gt; 绝对路径绝对路径D:\web\img\logo.gif 或完整的网络地址http://www.baidu.com/img/logo.gif。 列表标签无序列表（重点）无序列表的各列表之间没有顺序级别之分，是并列的。其基本语法格式如下： 123456&lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ···&lt;/ul&gt; 注意事项：1、&lt;ul&gt;标签内除了&lt;li&gt;标签最好不要放其他标签。2、&lt;li&gt;标签相当于一个容器，里面可以包含其他标签，如&lt;p&gt;、&lt;h1&gt;等。3、无序列表有自己的属性，但通常由CSS来完成样式的调配。 有序列表（了解）12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;ol标签的使用&lt;/title&gt; &lt;meta charset = &quot;UTF-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;高考排行榜&lt;/h2&gt; &lt;ol&gt; &lt;li&gt;小明 分数：750&lt;/li&gt; &lt;li&gt;小红 分数：670&lt;/li&gt; &lt;li&gt;小黄 分数：490&lt;/li&gt; &lt;li&gt;小雨 分数：233&lt;/li&gt; &lt;/ol&gt; &lt;body&gt;&lt;/html&gt; 自定义列表（理解）自定义列表通常对术语或名词进行解释或描述，自定义列表的列表项前没有任何项目符号。 12345678910&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; ··· &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; ···&lt;/dl&gt; 应用的场景： 表格和表单表格table（会使用）表格现在还是一种较为常用的标签，但不是用来布局，常见处理和显示表格式数据。 创建表格创建表格的基本语法： 123456789&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ··· &lt;/tr&gt; &lt;tr&gt; ··· &lt;/tr&gt;&lt;/table&gt; 1、table用于定义一个表格。2、tr用于定义表格中的一行，必须嵌套在tabel标签内，在tabel标签中有几对tr标签就有几行表格。3、td用于定义表格中的单元格，必须嵌套在tr标签内。4、td标签像一个容器，里边可以放其他标签。如：p、div、span等。 表格属性 属性名 含义 常用属性值 border 设置表格的边框（默认为0，无边框） 像素值 cellspacing 设置单元格与单元格边框之间的空白间距 像素值（默认为2） cellpadding 设置单元格内容与单元格边框之间的空白间距 像素值（默认为1） width 设置表格宽度 像素值 height 设置表格高度 像素值 align 设置表格在网页中的水平对齐方式 left、center、right 表头标签表头一般位于表格的第一行或第一列，一般要用特殊的格式突出显示表头。设置表头标签用&lt;th&gt;&lt;/th&gt;替代相应单元格标签&lt;td&gt;&lt;/td&gt;即可。 表格结构在使用表格进行布局时，可以将表格分为头部、主体。&lt;thead&gt;&lt;/thead&gt;用于定义表格的头部。&lt;tbody&gt;&lt;/tbody&gt;用于定义表格的主体。 表格标题caption元素定义表格的标题。 123&lt;table&gt; &lt;caption&gt;我是表格的标题&lt;/caption&gt;&lt;/table&gt; caption标签必须紧随table标签之后。只能对每个表格定义一个标签。标题会被居中于表格之上。 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;table使用&lt;/title&gt; &lt;meta charset = &quot;UTF-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;table&gt; &lt;caption&gt; 火影忍者演员表 &lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;!-- 表格样式留给CSS做 --&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;鸣人&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;佐助&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;19&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 合并单元格（难点）跨行合并：rowspan跨列合并：colspan 12345678910111213141516171819202122&lt;table&gt; &lt;caption&gt; 合并单元格 &lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;第一列&lt;/th&gt; &lt;th&gt;第二列&lt;/th&gt; &lt;th&gt;第三列&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td rowspan = &quot;2&quot;&gt;跨行合并&lt;/td&gt; &lt;td&gt;未合并&lt;/td&gt; &lt;td&gt;未合并&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan = &quot;2&quot;&gt;跨列合并&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 表单标签（掌握）我们在网页中，有时要与用户进行交互，收集用户信息，此时需要使用表单。 在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域三个部分构成。 表单控件：包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮等。提示信息：提示用户输入信息的提示性文字。表单域：相当于一个容器，用来容纳所有表单控件和提示信息。可以通过它来定义处理表单数据所用程序的URL地址，以及数据提交到服务器的方式。如果不定义表单域，表单中的数据无法传输到服务器。 input控件（重点）input标签为单标签，type实行为其最基本属性，其取值有多种，用于指定不同的控件类型。 123456789101112131415161718192021222324用户名：&lt;input type = &quot;text&quot; value = &quot;请输入用户名······&quot;/&gt; &lt;br /&gt;&lt;!-- 文本框 框内预先有value文本 --&gt;密 码：&lt;input type = &quot;password&quot; maxlength = &quot;6&quot; /&gt; &lt;br /&gt;&lt;!-- 密码框 最多输入六个字符 --&gt;性 别：&lt;input type = &quot;radio&quot; name = &quot;sex&quot; /&gt;男&lt;input type = &quot;radio&quot; name = &quot;sex&quot; /&gt;女 &lt;br /&gt;&lt;!-- 单选框 如果是一组，使用相同的name值来实现 --&gt;爱 好：&lt;input type = &quot;checkbox&quot; name = &quot;hobby&quot; checked = &quot;checked&quot;&gt;足球&lt;input type = &quot;checkbox&quot; name = &quot;hobby&quot;&gt;篮球&lt;input type = &quot;checkbox&quot; name = &quot;hobby&quot;&gt;乒乓球 &lt;br /&gt;&lt;!-- 复选框 checked默认已选 --&gt;按 钮：&lt;input type = &quot;botton&quot; value = &quot;搜索&quot; /&gt; &lt;br /&gt; &lt;!-- 普通按钮 --&gt;&lt;input type = &quot;submit&quot; value = &quot;提交&quot; /&gt; &lt;!-- 提交按钮 value有默认值 --&gt;&lt;input type = &quot;reset&quot; value = &quot;重置表单&quot; /&gt; &lt;br /&gt; &lt;!-- 重置按钮 --&gt;&lt;input type = &quot;image&quot; src = &quot;ing.jpg&quot; /&gt; &lt;br /&gt; &lt;!-- 图像按钮 --&gt;上传头像：&lt;input type = &quot;file&quot; /&gt; &lt;!-- 文件按钮 可上传文件 --&gt; label标签（理解）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象（下）]]></title>
    <url>%2F2019%2F04%2F26%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%8B)%2F</url>
    <content type="text"><![CDATA[继承继承的实现继承让我们更加容易实现类的扩展。例如，我们定义了动物类，再定义哺乳动物类只需要扩展动物类即可，实现了代码的重用。 12345678910111213141516171819202122232425public class TestExtends&#123; public static void main(String[] args)&#123; Student stu = new Student(); stu.name = &quot;Tom&quot;; stu.height = 172; stu.rest(); &#125;&#125;class Person&#123; String name; int height; public void rest()&#123; System.out.println(&quot;休息一下！&quot;); &#125;&#125;class Student extends Person&#123; //继承关键字 String major; public void study()&#123; System.out.println(&quot;学习一会儿！&quot;); &#125;&#125; 继承的要点：1、父类也称作超类、基类等。2、Java中只有单继承，没有像C++那样的多继承，多继承会引起混乱，使得继承链复杂。3、Java中类没有多继承，接口有多继承。‘4、子类继承父类，可以得到父类的全部属性和方法（除了父类的构造方法），但不见得可以直接访问（比如父类私有的属性和方法）。5、如果一个类没有调用extends，则父类为java,lang.Object。 instanceof运算符instanceof是二元运算符，左边是对象，右边是类。当对象是右边类或子类所创建的对象时，返回true，否则返回false。 123456789public class Test&#123; public static void main(String[] args)&#123; Student s = new Student(); Person p = new Person(); System.out.println(&quot;s instanceof Person&quot;); //true System.out.println(&quot;s instanceof Student&quot;); //true System.out.println(&quot;p instanceof Student&quot;); //false &#125;&#125; 方法的重写override子类通过重写父类的方法，可以用自身的行为替换父类的行为。方法的重写是实现多态的必要条件。 方法重写的要点：1、方法名，形参列表相同。2、返回值类型和声明异常类型，子类小于等于父类。3、访问权限，子类大于等于父类。 123456789101112131415161718192021222324252627282930313233343536373839public class TestOverride&#123; public static void main(String[] args)&#123; Vehicle v1 = new Vehicle(); Vehicle v2 = new Horse(); Vehicle v3 = new Plane(); v1.run(); v2.run(); v3.run(); v2.stop(); v3.stop(); &#125; class Vehicle&#123; public void run()&#123; System.out.println(&quot;跑···&quot;)； &#125; public void stop()&#123; System.out.println(&quot;停止不动！&quot;); &#125; &#125; class Horse extends Vehicle&#123; public void run()&#123; System.out.println(&quot;四蹄翻飞，嘚嘚嘚嘚···&quot;); &#125; &#125; class Plane extends Vehicle&#123; public void run()&#123; System.out.println(&quot;天上飞!&quot;)； &#125; public void stop()&#123; System.out.println(&quot;空中不能停！&quot;); &#125; &#125;&#125; Object类Object类是所有Java类的根基类，所有Java对象都拥有Object类的属性和方法。 toString()方法Object类中定义有public String toString()方法，返回值类型为String。 1234//toString 源码public String toString()&#123; return getClass.getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125; 123456789101112131415161718192021toString()测试和重写toString方法class Person&#123; String name; int age; @Override public String toString()&#123; return name + &quot;年龄：&quot; + age; &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; Person p = new Person(); p.age = 18; p.name = &quot;Tom&quot;; System.out.println(&quot;Info:&quot; + p); //调用Person的toString方法 Test t = new Test(); System.out.println(t); //调用Object的toString方法 &#125;&#125; “==”和equals()方法== 代表比较双方是否相同。如果是基本类型则表示值相等，如果是引用类型则表示地址相等，即是同一个对象。 Object类中定义有public boolean eaquals(Object obj)方法，提供定义对象内容相等的逻辑。 1234//equals源码public boolean equals(Object obj)&#123; return (this == obj);&#125; 1234567891011121314151617181920212223//String类中对equals方法的重写public boolean equals(Object anObject)&#123; if(this == anObject)&#123; return true; &#125; if(anObject instanceof String)&#123; String anotherString = (String)anObject; int n = value.length; if( n == anotherString.value.length)&#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while(n-- != 0)&#123; if(v1[i] != v2[i])&#123; return false; &#125; i++; &#125; return ture; &#125; &#125; return false;&#125; 123456789101112131415161718192021222324252627282930313233343536373839//equals方法测试和自定义类重写equals方法public class TestEquals&#123; public static void main(String[] args)&#123; Person p1 = new Person(123,&quot;Tom1&quot;); Person p2 = new Person(123,&quot;Tom2&quot;); System.out.println(p1 == p2); //false System.out.println(p1.equals(p2)); //id相同，true String s1 = new String(&quot;qwer&quot;); String s2 = new String(&quot;qwer&quot;); System.out.println(s1 == s2); //false，地址不同 System.out.println(s1.equals(s2)); //true，字符串内容相同 &#125;&#125;class Person&#123; int id; String name; public Person(int id, String name)&#123; this.id = id; this.name = name; &#125; public boolean equals(Object obj)&#123; if(obj == null)&#123; return false; &#125; else&#123; if(obj instanceof Person)&#123; Person c = (Person)obj; if(c.id == this.id)&#123; return true; &#125; &#125; &#125; return false; &#125;&#125; super关键字super的使用super是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性。 若使用super调用普通方法，语句没有位置限制，可以在子类中直接调用。 若是构造方法的第一行没有显式地调用super(…)或this(…)，Java默认会调用super().调用父类的无参数构造方法，可以省略。 12345678910111213141516171819202122232425//super关键字的使用public class TestSuper&#123; public void main(String[] args)&#123; new ChildClass.f(); &#125;&#125;class FatherClass&#123; public int value; public void f()&#123; value = 100; System.out.println(&quot;FatherClass.value = &quot; + value); &#125;&#125;class ChildClass extends FatherClass&#123; public int value; public void f()&#123; super.f(); value = 200; System.out.println(&quot;ChileValue = &quot; + value); System.out.println(value); System.out.println(super.value); &#125;&#125; 继承树的追溯属性/方法查找顺序：（比如查找变量V）1、查找当前类中有没有属性V。2、依次上溯每个父类，查看每个类中是否有属性V，直到Object。3、没有找到，出现编译错误。4、只要找到变量V，过程停止。 构造方法调用顺序：构造方法第一句总是super()来调用父类对应的构造方法。先上溯到Object，然后再依次向下执行类的初始化块和构造方法，直到当前子类为止。静态初始化块调用顺序和构造方法调用顺序一样（Java面向对象（上）中有相关介绍）。 1234567891011121314151617181920//构造方法上溯执行测试public class TestSuper&#123; public void main(String[] args)&#123; System.out.println(&quot;开始创建一个ChildClass对象···&quot;); new ChildClass(); &#125;&#125;class FatherClass&#123; pubic FatherClass()&#123; System.out.println(&quot;创建FatherClass&quot;); &#125;&#125;class ChildClass extends FatherClass&#123; public ChildClass()&#123; //该行自动调用父类无参构造方法 System.out.println(&quot;创建ChildClass&quot;); &#125;&#125; 封装封装的作用及含义我们程序设计要追求“高内聚，低耦合”。高内聚就是内部的数据操作细节自己完成，不允许外部干涉，低耦合是仅暴露少量的方法给外部使用，尽量方便外部调用。 编程中封装的具体优点：1、提高代码的安全性。2、提高代码的复用性。3、高内聚，便于修改内部代码，提高可维护性。4、低耦合，便于调用者使用，便于扩展和协作。 使用访问控制符实现封装Java是使用“访问控制符”类控制哪些细节需要封装，哪些需要暴露的。 1、private表示私有，只有自己能访问。2、default表示没有修饰符修饰，只有同一个包的类能访问。3、protected表示可以被同一个包的类以及其他包的子类访问。4、public表示可以被该项目的所有包的所有类访问。 封装的使用细节类属性的处理：1、一般使用private访问权限。2、提供相应的set和get方法来访问相关属性，方法是public修饰的，提供属性的访问和读写操作。3、一些只用于本类辅助性方法可以用private修饰，希望其他类调用的方法用public修饰。 123456789101112131415161718192021222324252627282930//JavaBean的封装实例public class Person&#123; private String name; private int age; private boolean man; //属性使用private修饰 public String getName()&#123; return this.name; &#125; public void setName(String name)&#123; this.name = name; &#125; public int getAge()&#123; return this.age; &#125; public void setAge(int age)&#123; this.age = age; &#125; public boolean isMan()&#123; //boolean类型的get方法是is开头 return man; &#125; public void setMan(boolean man)&#123; this.man = man; &#125;&#125; 多态（polymorphism）多态的概念多态指的是同一个方法的调用，由于对象不同可能会有不同的行为。现实生活中，同一个方法，具体实现会完全不同。 多态的要点：1、多态是方法的多态，不是属性的多态（多态与属性无关）。2、多态的存在条件有三个必要条件：继承、方法重写、父类引用指向子类对象。3、父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了。 对象的转型（casting）父类指向引用子类的对象，我们称这个过程为向上转型，属于自动类型转换。 向上转型后的父类引用变量只能调用它编译类型的方法，不能调用它运行时类型的方法。这是我们需要进行强制类型转换，称之为向下转型。 123456789101112131415161718192021222324252627282930313233343536373839404142//测试多态和转型public class TestPolymorphism&#123; public static void main(String[] args)&#123; animalCry(new Animal); Animal d = new Dog(); //向上可以自动转型 animalCry(d); //Animal中的shout方法 //d.seeDoor(); //报错 Dog _d = (Dog)d; //向下转型 _d.seeDoor(); //Cat c = (Dog)d; //类型不匹配 animalCry(new Cat()); //Cat中shout方法 &#125; static animalCry(Animal a)&#123; a.shout(); &#125;&#125;class Animal&#123; public void shout()&#123; System.out.println(&quot;叫了一声！&quot;); &#125;&#125;class Dog extends Animal&#123; public void shout()&#123; System.out.println(&quot;汪汪汪！&quot;); &#125; public void seeDoor()&#123; System.out.println(&quot;看门!&quot;)； &#125;&#125;class Cat extends Animal&#123; public void shout()&#123; System.out.println(&quot;喵喵喵！&quot;); &#125;&#125; final关键字final关键字的作用：1、修饰变量：被修饰的变量不可改变。一旦赋初值，就不可被改变。1final int MAX_SPEED = 120; 2、修饰方法：该方法不可被子类重写，但是可以重载。1final void study()&#123;&#125; 3、修饰类：修饰类不能被继承，比如：Math、String等。1final class A&#123;&#125; 抽象方法和抽象类抽象方法使用abstract修饰的方法，没有方法体，只有声明。定义的是一种规范，就是告诉子类必须要给抽象方法具体的实现。 抽象类包含抽象方法的类就是抽象类。通过abstract方法定义规范，然后要求子类必须定义具体实现。通过抽象类，我们就可以严格限制子类的设计，使子类之间更加通用。 1234567891011121314151617181920212223//抽象类和抽象方法的基本使用abstruct class Animal&#123; //抽象类 abstruct public void shout(); //抽象方法&#125;class Dog extends Animal&#123; //子类必须实现父类的抽象方法，否则编译错误 public void shout()&#123; System.out.println(&quot;汪汪汪！&quot;); &#125; public void seeDoor()&#123; System.out.println(&quot;看门中···&quot;); &#125;&#125;public class TestAbstructClass&#123; public static void main(String[] args)&#123; Dog a = new Dog(); a.shout(); a.seeDoor(); &#125;&#125; 抽象类的使用要点1、有抽象方法的类只能定义成抽象类。2、抽象类不能被实例化，即不能用new来实例化抽象类。3、抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用。4、抽象类只能用来被继承。5、抽象方法必须被子类实现。 接口什么是接口（抽象类和接口的对比）接口就是比“抽象类”还抽象的“抽象类”，可以更加规范的对子类进行约束。全面而专业的实现了：规范和具体实现的分离。 抽象类还提供某些具体实现，接口不提供任何实现，接口中所有方法都是抽象方法。接口是完全面向规范的，规定了一批类具有的公共方法规范。 接口是两个模块之间通信的标准，通信的规范。如果能把你要设计的模块之间的接口定义好，就相当于完成了系统的设计大纲，剩下的就是具体实现了。 接口和实现类不是父子关系，是实现规则的关系。比如：定义一个Runnable接口，Car实现它就能在地上跑，Train实现它也能在地上跑。如果它是交通工具就一定能跑，但是必须实现Runnable接口。 如何定义和使用接口12345//声明格式[访问修饰符] interface 接口名 [extends 父接口1、父接口2···]&#123; 常量定义; 方法定义;&#125; 定义接口的详细说明：1、访问修饰符：只能是public或默认。2、接口名：和类名采用相同命名机制。3、extends：接口可以多继承。4、常量：接口中的属性只能是常量，总是public static final修饰。不写也是。5、方法：接口中的方法只能是public abstract。省略也是。 要点：1、子类通过implements来实现接口中的规范。2、接口不能创建实例，但是可以用于声明引用变量类型。3、一个类实现了接口，必须实现接口中所有方法，并且方法只能是public。 12345678910111213141516171819202122232425262728293031323334353637383940//接口的使用public class TestInterface &#123; public static voic main(String[] args)&#123; Volant v = new Angle(); v.fly(); System.out.println(&quot;v.FLY_HEIGHT&quot;); Honest h = new GoodMan(); h.helpOther(); &#125;&#125;//飞行接口public interface Volant&#123; int FLY_HEIGHT = 100; //总是public static final类型的 void fly(); //总是public abstract void fly();&#125;//善良接口public interface Honest&#123; void helpOther();&#125;//Angle类实现飞行接口和善良接口class Angle implements Volant,Honest&#123; //多继承 public void fly&#123; System.out.println(&quot;我是天使，我会飞。&quot;); &#125; public void helpOther()&#123; System.out.println(&quot;帮助别人。&quot;); &#125;&#125;//GoodMan类实现Honest接口class GoodMan implements Honest&#123; public void helpOther()&#123; System.out.println(&quot;扶老奶奶过马路。&quot;); &#125;&#125; 面向接口编程面向接口编程是面向对象编程的一部分。 接口就是规范，是项目中最稳定的东西。面向接口编程让我们把握住最核心的东西，使实现复杂多变的需求成为可能。 通过面向接口编程，而不是面向实现类编程，可以大大降低程序模块之间的耦合性，提高整个系统的可扩展性和可维护性。 内部类在JAVA中内部类主要分为成员内部类（非静态内部类、静态内部类）、匿名内部类、局部内部类。 成员内部类成员内部类可以使用private、default、protected、public进行修饰。 非静态内部类外部类里使用非静态内部类和平时使用其他类没什么区别。 特点：1、非静态内部类必须寄存在一个外部类对象里。因此，如果存在一个非静态内部类对象那么一定存在对应的外部类对象。非静态内部类对象单独属于外部类的某个对象。2、非静态内部类可以直接访问外部类的成员，但是外部类不可以直接访问非静态内部类成员。3、非静态内部类不能有静态方法、静态属性和静态初始化块。4、外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例。5、成员变量访问要点： 1)内部类里方法的局部变量：变量名。 2)内部类属性：this.变量名。 3)外部类属性：外部类名.this.变量名。6、内部类的访问: 1)外部类中定义内部类：new Inner();。 2)外部类以外的地方使用非静态内部类：Outer.Inner varname = new Outer().new Inner();。 12345678910111213141516171819202122232425//测试非静态内部类public class TestInnerClass&#123; public static void main(String[] args)&#123; Outer.Inner inner = new Outer().new Inner(); //创建内部类对象 inner.show(); &#125;&#125;class Outer&#123; private int age = 10; public void testOuter()&#123; System.out.println(&quot;Outer.testOuter.&quot;); &#125; class Inner&#123; int age = 20; public void show()&#123; int age = 30; System.out.println(&quot;外部类的成员变量age:&quot; + Outer.this.age); //访问外部类属性 10 System.out.println(&quot;内部类的成员变量age:&quot; + this.age); //访问外部类属性 20 System.out.println(&quot;局部变量age:&quot; + age); //访问外部类属性 30 &#125; &#125;&#125; 静态内部类要点：1、当一个静态内部类对象存在，并不一定存在对应的外部类对象。因此，静态内部类的实例方法不能直接访问外部类的实例方法。2、静态内部类看作外部类的一个静态成员。因此，外部类的方法中可以通过：“静态内部类.名字”的方式访问静态内部类的成员变量，通过new 静态内部类()访问静态内部类的实例。 123456789101112//静态内部类的访问class Outer&#123; static class Inner&#123; //相当于外部类的静态成员 &#125;&#125;public class TestStaticInnerClass&#123; public static void main(String[] args)&#123; //通过new 外部类.内部类()来创建内部类对象 Outer.Inner inner = new Outer.Inner(); &#125;&#125; 匿名内部类适合只需要使用一次的类。比如：监听键盘操作等等。 语法：123new 父类构造器(实参)\实现接口()&#123; 匿名内部类类体&#125; 123456789101112131415161718//匿名内部类的使用this.addWindowListener(new WindowAdapter()&#123; @Override public void windowClosing(WindowEvent e)&#123; System.exit(0); &#125;&#125;);this.addKeyListener(new KeyAdapter()&#123; @Override public void keyPressed(KeyEvent e)&#123; myTank.keyPressed(e); &#125; @Override public void keyReleased(KeyEvent e)&#123; myTank.keyReleased(e); &#125;&#125;); 注意：1、匿名内部类没有访问修饰符。2、匿名内部类没有构造方法。 局部内部类局部内部类定义在方法内部，作用域仅限于本方法。 1234567891011121314public class Test&#123; public void show()&#123; class Inner&#123; //作用于仅限于本方法 public void fun()&#123; System.out.println(&quot;局部内部类&quot;); &#125; &#125; new Inner().funn(); &#125; public static void main(String[] args)&#123; new Test().show(); &#125;&#125; String基础String类基本特点1、String类又称作不可变字符序列。2、String位于java.lang包中，java程序默认导入java.lang中的所有类。3、Java字符串就是Unicode字符序列。4、Java没有内置字符串类型，而是在标准Java类库里提供预定义的类String，每个用双引号括起来的字符串都是String类的一个实例。5、Java允许使用“+”将字符串连接。 String类和常量池在Java的内存分析中，我么你经常会听到关于“常量池”的描述，实际上常量是分为一下三种：1、全局字符串常量池（String Pool） 全局字符串常量池中存放的内容是在类加载完成后存到String Pool中的，在每个VM中只有一份，存放的是字符串常量的引用值（在堆中生成字符串对象实例）。2、class文件常量池（Class Constant Pool） class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量（文本字符串、final常量等）和符号引用。3、运行时常量池（Runtime Constant Pool） 运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。 1234567891011//常量池public class Test&#123; public static void main(String[] args)&#123; String str1 = &quot;Tom&quot;; String str2 = &quot;Tom&quot;; String str3 = new String(&quot;Tom&quot;); System.out.println(str1 == str2); //true，Tom放在常量池中，同一个对象 System.out.println(str1 == str3); //false，新建的对象 &#125;&#125; 因此：通常比较字符串时，使用equals。 String类常用方法 方法 解释说明 char charAt(int index) 返回字符串中第index个字符 boolean equals(String other) 如果字符串与other相等，返回true；否则返回false boolean equalsIgnoreCase(String other) 如果字符串与other相等（忽略大小写），返回true；否则返回false int indexOf(String str) 返回从头开始查找第一个子字符串str在字符串中的索引位置。如果未找到字符串str，返回-1 int lastIndexOf(String str) 返回从末尾开始查找第一个子字符串str在字符串中的索引位置。如果未找到字符串str，返回-1]]></content>
      <categories>
        <category>Java知识体系</category>
      </categories>
      <tags>
        <tag>Java知识体系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象（上）]]></title>
    <url>%2F2019%2F04%2F23%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[对象和类对象和类的概念对象是个内存块，里面放相关联的数据和相关方法。类可以看作是对象的模板，或者图纸，系统根据类的定义来造出对象。对象我们叫做Object，instance（实例）。类我们叫class。 定义一个类12345678910// 类的定义方式public class Car&#123; //每一个源文件必须有且只有一个public class，并且该类名和文件名保持一致。 ···&#125;class Type&#123; //一个Java文件可以定义多个class。 ···&#125;class Engine&#123; ···&#125; 对于一个类来说，一般有三种常见的成员：属性field、方法method、构造器constructor。这三种成员都可以定义零个或多个。 1234567891011121314151617//简单的学生类编写public class Student&#123; //属性（成员变量） int id; String name; int age; //方法 void study()&#123; System.out.println(&quot;我正在学习！&quot;); &#125; //构造方法 无参构造方法可以由系统自动创建 Student()&#123; &#125;&#125; 属性：也叫成员变量，用于定义该类或该类对象的静态特征。属性的作用范围是整个类体。方法：用于定义该类或该类实例的行为特征和功能实现，面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。 面向对象的内存分析Java虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area。 12345678910111213141516171819202122232425262728293031323334示例代码：Student.javapublic classs Student&#123; int id; String name; int age; Computer comp; void study()&#123; System.out.println(&quot;我正在学习！&quot;); &#125; viod play()&#123; System.out.println(&quot;我正在玩游戏！使用&quot;+comp.brand+&quot;电脑。&quot;); &#125; public static void main(String[] args)&#123; Student stu = new Student(); sdu.id = 101; stu.name = &quot;Tom&quot;; stu.age = 18; Computer c1 = new Computer; c1.brand = &quot;HP&quot;; stu.comp = c1; stu.play(); stu.study(); &#125;&#125;class Computer&#123; String brand;&#125; 栈栈的特点：1、栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧（存储局部变量、操作数、方法出口等)。2、JVM为每个线程创建一个栈，用于存放该线程执行方法的信息（实际参数、局部变量等）。3、栈属于线程私有，不能实现线程间的共享。4、栈的存储特点是“先进后出，后进先出”。5、栈是由系统自动分配，速度快，栈是连续的内存空间。 堆堆的特点：1、堆用于存储创建好的对象和数组（数组也是对象）。2、JVM只有一个堆，被所有线程共享。3、堆是一个不连续的内存空间，分配灵活，速度慢。 方法区方法区（静态区）的特点：1、JVM只有一个方法区，被所有线程共享。2、方法去实际也是堆，只是用于存储类、常量相关的信息。3、用来存放程序中永远是不变或唯一的内容（类信息，即class对象、静态变量、字符串常量等）。 构造器概念构造器也叫构造方法（constructor），用于对象的初始化。 要点：1、通过new关键字调用。2、构造器虽然有返回值，但是不能定义返回值类型，不能用return返回某个值。3、如果没有定义构造器，编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加。4、构造器的方法名必须和类名一致。 构造器的重载构造器的重载和方法的重载类似，同名不同参的构造方法可以在一个类中定义多个。 123456789101112131415161718192021222324252627public class User&#123; int id; String name; String password; public User()&#123; &#125; public User(int id,String name)&#123; super(); //构造方法的第一句总是super(); this.id = id; //this表示创建好的对象。 this.name = name; &#125; public User(int id,String name,String password)&#123; super(); this.id = id; this.name = name; this.password = password; &#125; public static void main(String[] args)&#123; User u1 = new User(); User u2 = new User(100,Tom); User u2 = new User(200,Alice,1234567); &#125;&#125; 垃圾回收机制（Garbage Collection）Java有垃圾回收机制这一特性，从而简化开发。 垃圾回收原理和算法内存管理：Java的内存管理很大程度指的是对象的管理，其中包括对象空间的分配和释放。对象空间的分配：使用new关键字创建对象即可。对象空间的释放：将对象赋值null即可。垃圾回收机制负责回收所有不可达对象的内存空间。 垃圾回收过程：任何一种垃圾回收算法一般要做两件事情：1、发现无用的对象。2、回收无用对象占用的内存空间。 垃圾回收相关算法： 1、引用计数法堆中每个对象都有一个引用计数。被引用一次计数加1，被引用变量值变为null，计数减1，直到计数为0，则表示变成无用对象。优点是算法简单，缺点是“循环引用的无用对象”无法识别。 123456789101112131415//循环引用示例public class Student &#123; String name; Student friend; public static void main(String[] args)&#123; Student s1 = new Student(); Student s2 = new Student(); s1.friend = s2; s2.friend = s1; s1 = null; s2 = null; &#125;&#125; s1和s2互相引用对方，导致计数不为零，但是实际上已经无用，但无法被识别。 2、引用可达法（根搜索算法） 程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点被认为是没有被引用的节点，即无用的节点。 通用分代垃圾回收机制分代垃圾回收机制，基于一个事实：不同的对象的生命周期是不同的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为Eden、Survivor和Tenured/Old空间。 1、年轻代所有新生成的对象首先放在Eden区。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。对应的是Minor GC，每次Minor GC会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作但是会浪费内存空间。当“年轻代”区域存满后，就将对象放在年老代区域。 2、年老代在年轻代中经历了N（默认15）次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启用Major GC和Full GC（全量回收），来一次大扫除，全面清理年轻代区域和年老代区域。 3、持久代用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。 ·Minor GC：用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用的对象，将有用对象复制到“Survivor1”、“Survivor2”区中（这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个区域在用，一个为空）。 ·Major GC：用于清理年老代区域。 ·Full GC：用于清理年轻代、年老代区域。成本较高，会对系统性能产生影响。 垃圾回收过程： 1、新创建的对象，绝大多数会被存放到Eden区。2、当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用的对象清理掉，然后剩余对象复制到某个Survivor中，如s1，同时清空Eden区。3、当Eden区再次满了，会将s1中不能清理的对象存到另外一个Survivor中，如s2，同时将Eden区不能清空的对象，也复制到s2中，保证Eden和s1被清空。4、重复多次（15次）Survivor中没有被清理的对象，则会被复制到老年代Old区中。5、当Old区满了，则会触发一次完整的垃圾回收（Full GC）。 this关键字创建对象的过程创建一个对象分为四步：1、分配对象空间，并将对象成员变量初始化为0或null。2、执行属性值的显式初始化。3、执行构造方法。4、返回对象的地址给相关变量。 this的本质this的本质是“创建好的对象的地址”，由于在构造方法调用前，对象已经创建。因此可以在构造方法中使用this代表当前对象。 this最常用法1、在程序产生二义性之处，应使用this指明当前对象。普通方法中，this指向调用该方法的对象，构造方法中，this指向正要初始化的对象。2、使用this关键字调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中使用，并且只能在构造方法的第一句。3、this不能用在static方法中（static方法存储位置不同）。 1234567891011121314151617181920212223//this指明对象public class TestThis&#123; int a,b,c; TestThis(int a,int b)&#123; this.a = a; //指明本对象的成员变量a this.b = b; &#125; TestThis(int a, int b, int c)&#123; this(a,b); //调用上面的构造器,且必须位于第一句 this.c = c; &#125; void sing()&#123; System.out.println(&quot;I&apos;m singing!&quot;); &#125; void eat()&#123; this.sing(); //调用本类sing方法 System.out.println(&quot;I&apos;m eating!&quot;); &#125;&#125; static关键字在类中，用static声明的成员变量是静态成员变量，也称为类变量。类变量的生命周期和类相同，在整个应用程序执行期间都有效。它有如下特点：1、为该类的公共变量，属于类，被该类的所有实例共享，在该类被载入时显式初始化。2、对于该类的所有对象来说，static成员变量只有一份。被该类的所有对象共享。3、一般用“类名.类属性/方法”来调用，也可以通过对象引用或类名（不需要实例化）访问静态成员。4、在static方法中不能直接访问非static的成员。 核心要点：static修饰的成员变量和方法从属于类，普通变量和方法从属于对象。 1234567891011121314151617181920212223242526272829//测试static用法public class User&#123; int id; String name; String password; static String company = &quot;腾讯&quot;; public User(int id, String name)&#123; this.id = id; //this代指对象 this.name = name; &#125; public void login()&#123; System.out.println(&quot;登陆：&quot; + name); System.out.println(company); //普通方法可以调用静态成员 &#125; public static void printCompany()&#123; login(); //调用非静态成员会报错 System.out.println(company); &#125; public static void main(String[] args)&#123; User u = new User(100,&quot;Tom&quot;); User.printCompany(); User.company = &quot;阿里&quot;; User.printCompany(); &#125;&#125; 静态初始化块构造方法用于对象的初始化。静态初始化块，用于类的初始化操作。在静态初始化块中不能直接访问非static成员。 静态初始化块执行顺序：1、上溯到Object类，先执行Object类的静态初始化块，再向下执行子类的静态初始化块，直到我们的类的静态初始化块为止。2、构造方法执行和上述方法一样。 1234567891011121314151617181920public class User&#123; int id; String name; String password; static String company; static&#123; System.out.println(&quot;执行静态初始化工作。&quot;); company = &quot;腾讯&quot;; printCompany(); &#125; public static void printCompany()&#123; System.out.println(&quot;company&quot;); &#125; public static void main(String[] args)&#123; User u = null; &#125;&#125; 参数传递机制Java中，方法的所有参数都是“值传递”，也就是说“传递的是值的副本”。我们得到的是“原参数的复印件”，而不是原件。因此，复印件不会改变原件。 传递的是值的副本。但是引用类型指的是“对象的地址”。因此副本和原参数都指向了同一个“地址”，改变“副本指向地址对象的值，也意味着原参数指向对象的值也发生了改变”。 1234567891011121314151617181920212223242526272829//多个变量指向同一个对象public class User&#123; int id; String name; String password; public User(int id, String name)&#123; this.id = id; this.name = name; &#125; public void testParameterTransfer1(User u)&#123; u.name = &quot;Tom&quot;; &#125; public void testParameterTransfer2(User u)&#123; u = new User(200, &quot;David&quot;); &#125; public static void main(String[] args)&#123; User u1 = new User(100, &quot;Alice&quot;); u1.testParameterTransfer1(u1); System.out.println(u1.name); //Tom u1.testParameterTransfer2(u1); System.out.println(u1.name); //依旧是Tom &#125;&#125; 包包机制是Java中管理类的重要手段。开发中，我们会遇到大量重名的类，通过包我们可以解决类重名的问题，也可以实现对类的有效管理。包对于类，相当于文件夹对于文件的作用。 通过package实现对类的管理，package的使用有两个要点：1、通常是类的第一句非注释性语句。2、包名：域名倒着写，再加上模块名便于管理。 123//package命名举例package com.sum.test;package com.oracle.test; 写项目时都要加包，不要使用默认包。 JDK中的主要包： import导入普通导入如果我们要使用其他包的类，需要使用import导入，从而可以在本类中直接同过类名调用，否则就要通过书写类的完整包名和类名。 要点：1、Java会默认导入java.lang包下所有的类因此这些类可以直接使用。2、如果导入两个重名的类，只能用包名+类名来显式调用相关类。 1234567891011import java.sql.Date;import java.util.*; //导入该包下所有的类，降低编译速度，不降低运行速度public class Test&#123; public static void main(String[] args)&#123; Date now1; //这里指java.sql.Date java.util.Date now2 = new java.util.Data(); //java.util.Date和java.sql.Date重名，需要完整路径 System.out.pringln(&quot;now2&quot;); Scanner input = new Scanner(System.in); //非同名类不需要完整路径 &#125;&#125; 静态导入静态导入用于导入指定类的静态属性，这样我们可以直接使用静态属性。 12345678910package test;import static java.lang.Math.* //导入Math类的所有静态属性import static java.lang.Math.PI; //导入Math类的PI属性public class Test&#123; public static void main(String[] args)&#123; System.out.println(PI); System.out.println(random()); &#125;&#125;]]></content>
      <categories>
        <category>Java知识体系</category>
      </categories>
      <tags>
        <tag>Java知识体系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础语法]]></title>
    <url>%2F2019%2F04%2F16%2FJava%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[注释单行注释：使用 “//“ 开头，后面的单行内容为注释。 多行注释：以 “/“ 开头， “/“ 结尾，中间内容为注释，不能嵌套使用。 文档注释：以 “/*“ 开头， “/“ 结尾，包含说明性的文字及一些JavaDoc标签，写项目时可以生成项目API。 标识符使用规范表示类名的标识符：每个单词首字母大写，如BallGame、Player。。 表示方法和变量的标识符：满足“驼峰规则”，如eat(),eatFood()。 Java关键字和保留字 变量声明变量12double salary;int age; 变量类型可以是基本类型，也可以是引用类型。 变量分类 类型 声明位置 从属于 生命周期 局部变量 方法或语句块内部 方法/语句块 从声明位置开始，直到方法或语句块执行完毕，局部变量消失 成员变量（实例变量） 类内部，方法外部 对象 创建对象，成员变量也跟着创建，对象消失，成员变量也跟着消失 静态变量（类变量） 类内部，static修饰 类 类被加载，静态变量就有效，类被卸载，静态变量就消失 整型数据类型 类型 占用存储空间 byte 1字节 short 2字节 int 4字节 long 8字节 特殊进制表示方法： 八进制整数：以0开头，如：013十六进制数：以0x或0X开头，如：0x15二进制数：以0b或0B开头，如0b011001011 浮点型数据 类型 占用存储空间 float 4字节 double 8字节 浮点数和整数的比较java.math包下有两个类：BigInteger和BigDecimal,这两个类可以处理任意长度的数值。BigInteger实现了任意精度的整数运算。BigDecimal实现了任意精度的浮点运算。 12345678910111213BigDecimal bd = BigDecimal.valueOf(1.0); //bd = 1.0bd = bd.substract(BigDecimal.valueOf(0.1));bd = bd.substract(BigDecimal.valueOf(0.1));bd = bd.substract(BigDecimal.valueOf(0.1));bd = bd.substract(BigDecimal.valueOf(0.1));bd = bd.substract(BigDecimal.valueOf(0.1)); //bd减0.1System.out.println(bd);System.out.println(1.0 - 0.1 - 0.1 - 0.1 - 0.1 - 0.1); //0.50000000000000001 有误差BigDecimal bd1 = BigDecimal.valueOf(0.1);BigDecimal bd2 = BigDecimal.valueOf(1.0/10.0);System.out.println(bd1.equals(bd2)); //true 字符型数据char类型用来表示在Unicode的编码表中的字符。Unicode编码被设计用来处理各种语言的文字，占两个字节。 Unicode具有从0到65535之间的编码，通常用从’\u0000’到’\uFFFF’之间的十六进制值来表示。 转义字符： 转义符 含义 Unicode值 \b 退格（backspace） \u0008 \n 换行 \u000a \r 回车 \u000d \t 制表符（tab） \u0009 \” 双引号 \u0022 \’ 单引号 \u0027 \\ 反斜杠 \u005c boolean类型数据boolean类型有两个常量值，true和false，在内存中占一位（不是一个字节），不可以使用0或非0的整数替代。 运算符二元运算符Java中二元运算符与C中大同小异，包含：’+’ ‘-‘ ‘*’ ‘/‘ ‘%’。 运算规则： ·如果两个操作数有一个为long，结果为long。·没有long时，结果为int，即使操作数全为short，byte，结果也是int。·如果两个操作数有double，结果为double。·只有两个操作数都是float，结果才为float。·求余运算，余数符号与左边操作数相同，如：7 % 3 = 1，-7 % 3 = -1，7 % (-3) = 1。 一元运算符包含 ‘++’,’–’,用法与C相同。 赋值运算符和扩展赋值运算符 关系运算符 位运算符 1234int a = 3 * 2 * 2;int b = 3 &lt;&lt; 2; //相当于3 * (2^2)int c = 12 / (2^2);int d = 12 &gt;&gt; 2;//相当于12/2/2 条件运算符语法格式：1x ? y : z; 1234int a = 14;int b = 10;int max;max = a &gt; b ? a : b; 自动类型转换自动类型转换只容量小的数据类型可以自动转换成容量打的数据类型。 实线表示无数据丢失的自动类型转换，虚线表示转换时可能会有精度的损失。 强制类型转换在变量前用括号指定类型。1(type)var; 12double x = 3.14;int nx = (int)x; //值为3 使用Scanner获得键盘输入12345678910111213import java.util.Scanner; 导入包public class TextScanner&#123; public static void main(String[] args)&#123; Scanner scanner = new scanner(System.in); System.out.println(&quot;请输入名字:&quot;); String name = Scanner.nextLine(); System.out.println(&quot;请输入爱好：&quot;); String favor = Scanner.nextLine(); System.out.println(&quot;请输入年龄：&quot;); int age = Scanner.nextInt(); &#125;&#125; 选择结构语法结构：1234//if 单选择结构if(布尔表达式)&#123; 语句块&#125; 1234567// if else 双选择结构if(布尔表达式)&#123; 语句块&#125;else&#123; 语句块&#125; 12345678910111213// switch 多选择结构switch(表达式)&#123; case 值1: 语句序列1; break; case 值2: 语句序列2; break; …………………………………… default: 默认语句; break;&#125; 循环结构语法结构：1234// while循环while(布尔表达式)&#123; 语句块;&#125; 1234// do whiledo&#123; 语句块;&#125;while(布尔表达式); //分号不能省略 1234// for循环for(初始表达式;布尔表达式;；迭代因子)&#123; 语句块;&#125; 方法基本概念方法是一段用来完成特定功能的代码片段，类似于其他语言的函数。 方法的结构：123[修饰符1，修饰符2···] 返回值类型 方法名(形式参数列表)&#123; Java语句;&#125; 虚高东两个概念：·形式参数：在方法声明时用于接收外界传入的数据。·实参：调用方法时实际传给方法的数据。 12345678910111213public class method&#123; public static void main(String[] args)&#123; int n1 = 3; int n2 = 8; int sum = add(n1,n2); //n1,n2为实参 System.println(sum); &#125; public static int add(n1,n2)&#123; return n1+n2; &#125;&#125; 方法的重载(overload)方法的重载是指一个类中可以定义多个方法名相同，但参数不同的方法。调用时，会根据不同的参数自动匹配对应的方法。重载的方法只是名称相同而已，实际是完全不同的方法。 构成重载的条件：·不同的含义：形参类型，形参顺序，形参个数不同。·只有返回值不同不构成重载。如：1234567int a(String str)&#123; ···&#125;和void a(String str)&#123; ···&#125; 不构成重载。·只有形参的名称不同，不构成重载。 123456789101112131415161718public class method&#123; public static void main(String[] args)&#123; int n1 = 3; int n2 = 8; int sum = add(n1,n2); //n1,n2为实参 System.println(sum); &#125; public int add(n1,n2)&#123; return n1+n2; &#125; //方法重载 public int add(n1,n2,n3)&#123; return n1+n2+n3; &#125; &#125; 递归结构递归结构包括两个部分：·递归头：什么时候不调用自身方法。如果没有递归头，将陷入死循环，递归头是递归的结束条件。·递归体：什么时候需要调用自身方法。 12345678static long factorial(int n)&#123; if(n == 1)&#123; //递归头 return 1; &#125; else&#123; //递归体 return n*factorial(n-1); &#125;&#125; 注意事项：在高性能的情况下尽量避免使用递归，递归调用既花时间，又耗内存。]]></content>
      <categories>
        <category>Java知识体系</category>
      </categories>
      <tags>
        <tag>Java知识体系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Spring实战》笔记]]></title>
    <url>%2F2019%2F04%2F16%2FSpring%2F</url>
    <content type="text"><![CDATA[一·Spring之旅1.1 简化Java开发Spring是一个基于IOC和AOP的结构J2EE系统的框架。Spring是一个开源框架，可以使用该框架来简化Java开发，为了降低Java开发的复杂性，Spring采取了以下四种关键策略：·基于POJO的轻量级和最小入侵性编程。·通过依赖注入和面向接口实现松耦合。·基于切面和惯例进行声明式编程。·通过切面和模板减少样板式代码。 1.1.1 激发POJO的潜能首先介绍什么是POJO：“Plain Ordinary Java Object”即“简单的Java对象”。POJO的内在含义是指那些没有从任何类继承、也没有实现任何接口，更没有被其它框架侵入的java对象。例如： 12345public class HelloWorldBean &#123; public String sayHello &#123; return &quot;Hello World&quot;; &#125;&#125; 1.1.2 依赖注入（DI）什么是依赖？对象的关系一般有两种：is a ： 是一个， 继承关系。has a ：有一个， 成员变量，依赖关系。 123class A&#123; private B b; //A类依赖B类&#125; 依赖：一个对象使用另一个对象。注入：通过setter方法进行另一个对象实例设置。 依赖注入 Dependency Inject. 简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。 DI功能如何实现DI的目的是使对象的依赖关系降低。即降低耦合性。 123456789101112//紧耦合的代码public class DamselRescuingKnight implements Knight &#123; private RescueDamselQuest quest; public DamselRescuingKnight() &#123; this.quest = new RescueDamselQuest(); //在类中实例化了对象，耦合程度紧。 &#125; public void embarkOnQuest() &#123; quest.embark(); &#125;&#125; 紧耦合会使代码难以复用、难以测试、难以理解。 123456789101112//松耦合代码public class BraveKnight implements Knight &#123; private Quest quest; public BraveKnight(Quest quest) &#123; //构造器注入 this.quest = quest; &#125; public void embarkOnQuest() &#123; quest.embark(); &#125;&#125; BraveKnight没有与任何特定的Quest实现发声耦合，只要实现了Quest接口，具体使哪类的Quest无关紧要，提高了代码复用性。 如何工作Spring通过应用上下文装载bean的定义并把它们组织起来。 1.1.3 应用切面（AOP）面向切面编程，允许你将遍布应用各处的功能分离形成可用的组件。使服务模块化，确保POJO的简单性。 一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。 1.1.4 使用模板消除样板式代码样板式代码：为了实现通用的和简单的功能，不得不重复编写的代码。例如使用JDBC访问数据库查询数据。Spring旨在通过模板封装来消除样板式代码。 1.2容纳你的Bean在基于Spring的应用中，你的应用对象生存于Spring容器中。对象由Spring容器创建和装配，并存在于容器之中。容器是Spring框架的核心。Spring自带了多个容器的实现，可以归为两种不同的类型。1.Bean工厂。2.应用上下文。 1.2.1 使用应用上下文Spring自带多种类型的应用上下文，下面罗列两个： ClassPathXmlApplicationContext: 从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。12ApplicationContext context = new ClassPathXmlApplicationContext(&quot;文件路径.xml&quot;); //文件系统路径 FileSystemXmlApplicationContext:从文件系统下的一个或多个XML配置文件中加载上下文定义。12ApplicationContext context = new FileSystemXmlApplicationContext(&quot;文件名.xml&quot;); //类路径下查找 应用上下文准备就绪后，可以调用上下文的getBean()方法从Spring容器中获取bean。 1.2.2 bean的生命周期 1.3俯瞰Spring风景线Spring框架之内，关注与通过DI，AOP和消除样板式代码来简化企业级Java开发。但在Spring框架之外，还存在一个构建在核心框架之上的庞大生态圈，将Spring扩展到不同领域，例如Web服务、REST（一种针对网络应用的设计和开发方式）、移动开发以及NoSQL（非关系型数据库,如MongoDB）。 1.3.1 Spring模块 1.3.2 Spring Portfoliospring protfolio几乎为每一个领域的java开发提供了编程模型：1.Spring Web Flow2.Spring Web Service3.Spring Security4.Spring Integretion5.Spring Batch6.Spring Data7.Spring Social8.Spring Mobile9.Spring for Android10.Spring boot 1.4 Spring的新功能不讲。 二·装配BeanSpring中装配bean有多种方式，先介绍配置Spring容器最常见三种方法。 2.1 Spring配置的可选方案Spring提供了主要的装配机制：·在XML中进行显示配置；·在Java中进行显示配置；·隐式的bean发现机制和自动装配。 建议尽可能地使用自动装配机制，显示配置越少越好。其次时JavaConfig。最后考虑XML。 2.2 自动化装配beanSpring从两个角度来实现自动化装配：·组件扫描：Spring会自动发现应用上下文中所创建的bean。·自动装配：Spring自动满足bean之间的依赖。 2.2.1 创建可被发现的bean首先以CD来阐述DI如何运行：如果你不将CD插入（注入）到CD播放器中，那么CD播放器没有什么太大的用处。所以，CD播放器依赖于CD才能完成他的使命。 首先，在Java中建立CD的概念： 123456//定义CD的一个接口package soundsystem;public interface CompactDisc&#123; void play();&#125; 作为接口，它定义了CD播放器对一盘CD所能进行的操作。它将CD播放器的任意实现与CD本身的耦合降低到最小程度。 我们还需要一个CompactDisc的实现： 12345678910111213//带有@Component注解的CompactDisc实现类SgtPepperspackage soundsystem;import org.springframework.stereotype.Component;@Componentpublic class SgtPeppers implements CompactDisc&#123; //implements是实现一个接口用的关键字 private String title = &quot;Sgt.Pepper&apos;s Lonely Hearts Club Band&quot;; private String artist = &quot;The Beatles&quot;; public void play()&#123; System.out.println(&quot;Playing &quot;+ title + &quot;by &quot; + artist); &#125;&#125; SgtPeppers类上使用了@Component注解，这个注解表明该类会作为组件类，并告知Spring要为这个类创建Bean。不过，组件扫描默认是不启动的，还需要显示配置Spring，命令它区寻找带有@Component注解的类，并为其创建Bean。 123456789//@ComponentScan注解启用了组件扫描package soundsystem;import org.springframework.context.annotation.componentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScanpublic class CDPlayerConfig&#123;&#125; 类CDPlayerConfig通过Java代码定义了Spring的装配规则。CDPlayerConfig类并没有显式地声明任何bean，只不过它使用了@ComponentScan注解，这个注解能够在Spring中启用组件扫描。 1234567891011121314151617181920//测试组件扫描能够发现CompactDiscpackage soundsystem;import static org.junit.Assert.*;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.text.context.junit4.Spring.JUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class) //自动创建@ContextConfiguration(classes=CDPlayerConfig.class) //加载配置public class CDPlayerTest&#123; @Autowired private CompactDisc cd; @Test public void cdShouldNotBeNull()&#123; //断言cd属性不为空 assertNotNull(cd); &#125;&#125; CDPlayerTest使用Spring的SpringJUnit4ClassRunner，以便在测试开始的时候自动创建Spring的应用上下文。注解@ContextConfiguration会告诉它需要在CDPlayerConfig中加载配置。因为CDPlayerConfig类里包含了@ComponentScan，因此最终的应用上下文中应该包含CompactDisc bean。 2.2.2 为组件扫描的bean命名Spring应用上下文中所有的bean都会有一个ID，尽管我们没有给SgtPeppers bean设置ID，但Spring会给它设置为sgtPeppers，即首字母小写。 @Component注解设置ID1234@Component(&quot;lonelyHeartsClub&quot;) //将ID设为lonelyHeartsClubpublic class SgtPeppers implements CompactDisc&#123; ···&#125; @Named注解设置ID1234567package soundSystem;import javax.inject.Named;@Named(&quot;LonelyHeartsClub&quot;)public class SgtPeppers implements CompactDisc&#123; ···&#125; 推荐使用@Component注解来设置ID。 2.2.3 设置组件扫描基础包我们没有为@ComponentScan设置任何属性，按照默认规则，它会以配置类所在的包作为基础来扫描组件。而如果我们想将配置类放在一个包中，我们就要明确的设置基础包。 1234//@ComponentScan的value属性中指明包的名称@configuration@ComponentScan(&quot;soundSystem&quot;)public class CDPlayerConfig&#123;&#125; 1234//通过basePackages属性来强调配置基础包@configuration@ComponentScan(basePackages = &quot;soundSystem&quot;,&quot;vidio&quot;) //可以配置多个包public class CDPlayerConfig&#123;&#125; 上述例子中所配置的包是以String类型表示的但如果重构代码，所指定的基础包可能会出错。 1234//将其指定为包中所包含的类或接口@Configuration@ComponentScan(basePackageClasses = &#123;CDPlayer.class, DVDPlayer.class&#125;) //这些类所在包会作为组件扫描基础包public class CDPlayerConfig&#123;&#125;; 2.2.4 通过为bean添加注解实现自动装配自动装配就是让Spring自动满足bean依赖的一种方法，在满足依赖的过程中，会在Spring的应用上下文中寻找匹配某个bean需求的其他bean。 123456789101112131415161718在构造器中使用@Aotowired注解package soundSystem;import org.springframework.beans.factory.annotation.Aotowired;import org.springfranework.setereotype.Component;@Componentpublic class CDPlayer implements MediaPlayer&#123; private CompactDisc cd; @Aotowired //当Spring创建CDPlayer bean的时候，会通过构造器实例化，并传入一个可设置给CompactDisc类型的bean public CDPlayer(CompactDisc cd)&#123; this.cd = cd; &#125; public void play()&#123; cd.play(); &#125;&#125; 12345//在属性的Setter方法上使用@Aotowired@Aotowiredpublic void setCompactDisc(CompactDisc cd)&#123; this.cd = cd;&#125; @Aotowired注解可以用在类的任何方法上。Spring会尝试满足方法参数上声明的依赖。 如果没有匹配的bean在应用上下文创建的时候，Spring会抛出一个异常。可以将@Aotowired的required属性设置为false 1@Aotowired(required = false) 在自动装配中，Spring同时支持@Aotowired注解和@Inject注解。@Inject是Java依赖注入规范，大多数场景可以互相替换。 2.2.5 验证自动装配]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 1]]></title>
    <url>%2F2019%2F02%2F24%2FLeetcode-1%2F</url>
    <content type="text"><![CDATA[题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] C代码123456789101112131415int* twoSum(int* nums, int numsSize, int target) &#123; int i,j; static int a[2]; for(i = 0; i &lt; numsSize; i++)&#123; for(j = i +1; j &lt; numsSize; j++)&#123; if(nums[i] + nums[j] == target)&#123; a[0] = i; a[1] = j; return a; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建较长的宏]]></title>
    <url>%2F2019%2F01%2F28%2F%E5%88%9B%E5%BB%BA%E8%BE%83%E9%95%BF%E7%9A%84%E5%AE%8F%2F</url>
    <content type="text"><![CDATA[逗号运算符C语言中，“，”是一种运算符，成为逗号运算符。可以将许多表达式连接起来组成一个表达式，一般形式：表达式1，表达式2，表达式3······其求值是分别求两个表达式的值，并以最后的表达式的值作为整个逗号表达式的值。应用举例：12345678#include&lt;stdio.h&gt;int main()&#123; int a = 2,b = 3,c = 4; int x,y; y = ( (x = a + b) , b + c ); printf(&quot;x = %d, y = %d&quot;,x,y); return 0;&#125; 运行结果：x = 5, y = 7 创建较长的宏创建较长的宏时，逗号运算符会十分有用。例如：1#define ECHO(s) (gets(s),puts(s)) 如果不想使用逗号运算符，可以将函数放在花括号中形成复合语句:1#define ECHO(s) &#123; gets(s) ; puts(s) ;&#125; 但是这样在调用时也许会发生这样的情况：1234if (flag) ECHO(s);else gets(str); 这里ECHO后面的分号会使else没有配对。解决方法是将语句放在do循环中：12345#define ECHO(s) \ do&#123; \ gets(s);\ puts(s);\ &#125;while(0) 这样，调用时就是这种情况：1ECHO(str) \*do&#123; gets(str); puts(str); &#125;while(0); *\ 参考《C语言程序设计·现代方法》]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ALL in ALL]]></title>
    <url>%2F2019%2F01%2F17%2FALL-in-ALL%2F</url>
    <content type="text"><![CDATA[题目描述两个字符串s和t，判断是是否为t的子序列。 输入包括若干个测试数据，结束由EOF结束。 输出对每个测试数据，是子序列输出Yes,否则输出No。 样例输入sequence subsequenceperson compressionVERDI vivaVittorioEmanueleReDiItaliacaseDoesMatter CaseDoesMatter 样例输出YesNoYesNo 代码123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int solve(char *s ,char *t);#define maxn 110000char s[maxn],t[maxn];int main(int argc, char *argv[]) &#123; while( scanf(&quot;%s%s&quot;,s,t) != EOF )/*scamf以%s格式输入时，空格、换行符、TAB等是作为两个数据的分隔符存在的，即分隔符前后是两个数据，读入时分隔符不读如。*/ printf(&quot;%s\n&quot;,solve(s,t)?&quot;Yes&quot;:&quot;No&quot;); return 0;&#125;int solve(char *s ,char *t)&#123; int i,j,slen,tlen; slen = strlen(s); tlen = strlen(t); for(i = 0,j = 0; i &lt; slen &amp;&amp; j &lt; tlen;)&#123; if(s[i] == t[j])&#123; i++; j++; &#125; else j++; &#125; return i == slen;//判断是否将s字符串判断完。&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异或实现两数交换]]></title>
    <url>%2F2019%2F01%2F06%2F%E5%BC%82%E6%88%96%E5%AE%9E%E7%8E%B0%E4%B8%A4%E6%95%B0%E4%BA%A4%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[异或运算的概念定义：判断两个值是否不同，两个值相同时，返回false；两个值不同时，返回ture。 异或运用两数交换1.异或运算有个特点：对一个值连续做两次异或运算，会返回值本身。( x ^ y ) ^ y = x ^ 0 = x2.对于任何数x，都有x^x=0,x^0=x。3.交换律。4.结合律(a^b)^c == a^(b^c)。 利用如上性质，就可以实现不用引入中间变量而交换两个变量的值，节约储存空间。 1234int a,b;a = a ^ b;b = b ^ a;a = a ^ b; 两数最大值或最小值12min = (y ^ (x ^ y) &amp; - (x &lt; y) ) //最小值max = (x ^ (x ^ y) &amp; - (x &lt; y) ) //最大值]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[质数判定]]></title>
    <url>%2F2019%2F01%2F06%2F%E8%B4%A8%E6%95%B0%E5%88%A4%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[一·初等算法(试除法)用 n 除以从 2 ～ n^½ 的各个数，没有一个能够整除，即为质数。 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;math.h&gt;int isPrime(int n)&#123; int i; int flag = 1; scanf(&quot;%d&quot;,&amp;n); for(i = 2; i &lt;= sqrt(n); i++) &#123; if( n % i == 0 ) &#123; flag = 0; break; &#125; else continue; &#125; if(flag) return 1; else return 0;&#125; 二·初等算法改进篇判断2之后，直接判断从3到n^½的各个奇数，质数是不能被2整除的（查质数表一目了然，不再赘述）。 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;math.h&gt;int isPrime(int n)&#123; int i; int flag = 1; scanf(&quot;%d&quot;,&amp;n); if( n % 2 == 0 ) return 0; else &#123; for(i = 3; i &lt;= sqrt(n); i += 2) &#123; if( n % i == 0 ) &#123; flag = 0; break; &#125; else continue; &#125; &#125; if(flag) return 1; else return 0;&#125; 三·相邻法原理：大于等于5的质数一定和6的倍数相邻。 大于5的各个数用x表示：6x-1 6x 6x+1 6x+2 6x+3 6x+4 6x+5 6(x+1)其中，除了6x-1，6x+1和6x+5以外，其余的数都能够被2或3整除。 int isPrime(int n) { int i; if(n == 2 || n == 3 || n == 5) //筛去6以下的质数 return 1; if(n % 6 != 1 &amp;&amp; n % 6 != 5) //筛去没有与6相邻的数 return 0; for(i = 5; i &lt;=sqrt(n); i += 6) { if(n % i == 0 || n % (i+2) == 0) //筛去能被小的与6相邻数整除的数。 return 0; } return 1; } 实际使用起来前两个方法更加普遍，但效率较低，可以根据实际需求自行选择。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
