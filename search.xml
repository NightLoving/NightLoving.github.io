<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2020%2F01%2F13%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[动态代理： 特点： 字节码随用随创建，随用随加载。 作用： 不修改源码的基础上对方法增强。 分类： 基于接口的动态代理 基于子类的动态代理 基于接口的动态代理涉及的类： Proxy类，提供者JDK官方。如何创建代理对象： 使用Proxy类的newProxyInstance方法。创建代理对象的要求： 被代理对象至少实现一个接口，如果没有则不能使用。newProxyInstance方法的参数： ClassLoader：类加载器 它是用于加载代理对象字节码的。和被代理对象使用相同的类加载器。固定写法。 Class[]：字节码数组 它是用于让代理对象和被代理对象有相同的方法（实现相同的接口）。固定写法。 InvocationHandler：用于提供增强的代码 它是让我们写如何代理。一般写一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。此接口的实现类是谁用谁写。 接口12345public interface IProducer &#123; public void saleProduct(float money); public void afterService(float money);&#125; 实现类12345678910public class Producer implements IProducer&#123; public void saleProduct(float money)&#123; System.out.println(&quot;销售产品，并拿到钱：&quot;+money); &#125; public void afterService(float money)&#123; System.out.println(&quot;提供售后，并拿到钱：&quot;+money); &#125;&#125; 模拟顾客123456789101112131415161718192021222324252627282930313233343536import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class Client &#123; public static void main(String[] args) &#123; final IProducer producer = new Producer(); IProducer proxyproducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(), producer.getClass().getInterfaces(), new InvocationHandler() &#123; /** * 作用：执行被代理对象的任何接口方法都会经过该方法 * 方法参数的含义 * @param proxy 代理对象的引用 * @param method 当前执行的方法 * @param args 当前执行方法所需的参数 * @return 和被代理对象方法有相同的返回值 * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object reternValue = null; Float money = (Float) args[0]; if (&quot;saleProduct&quot;.equals(method.getName())) &#123; reternValue = method.invoke(producer, money * 0.8f); &#125; if (&quot;afterService&quot;.equals(method.getName())) &#123; reternValue = method.invoke(producer, money); &#125; return reternValue; &#125; &#125;); proxyproducer.saleProduct(10000f); proxyproducer.afterService(200f); &#125;&#125; 基于子类的动态代理涉及的类： Enhancer，提供者为第三方cglib库。如何创建代理对象： 使用Enhancer.create方法创建代理对象的要求： 被代理类不能是最终类。create方法的参数： Class：字节码 用于指定被代理类的字节码。 Callback：用于提供增强的代码 让我们写如何代理。一般嗾使写一个该接口的实现类，通常情况下是匿名内部类，但不是必须的。 此接口的实现类是谁用谁写。 一般写的都是该接口的子接口实现类：MethodInterceptor 父类12345678910public class Producer &#123; public void saleProduct(float money)&#123; System.out.println(&quot;销售产品，并拿到钱：&quot;+money); &#125; public void afterService(float money)&#123; System.out.println(&quot;提供售后，并拿到钱：&quot;+money); &#125;&#125; 模拟顾客1234567891011121314151617181920212223242526public class Client &#123; public static void main(String[] args) &#123; final Producer producer = new Producer(); Producer cglibProducer =(Producer) Enhancer.create(producer.getClass(), new MethodInterceptor() &#123; /** * 执行被代理对象的任何方法都会经过该方法 * @param o(proxy) * @param method * @param objects(args) * 以上三个参数和基于接口的动态代理中invoke方法的参数是一样的 * @param methodProxy ：当前执行方法的代理对象 * @return * @throws Throwable */ public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; Object returnValue = null; Float money = (Float)objects[0]; if(&quot;saleProduct&quot;.equals(method.getName()))&#123; returnValue = method.invoke(producer,money*0.8f); &#125; return returnValue; &#125; &#125;); cglibProducer.saleProduct(10000); &#125;&#125;]]></content>
      <categories>
        <category>Java知识体系</category>
      </categories>
      <tags>
        <tag>Java知识体系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构实验]]></title>
    <url>%2F2019%2F12%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[顺序栈基本操作编写程序实现表达式求值从键盘输入四则运算表达式字符串（以#结束），验证算术表达式的正确性，若正确，则计算该算术表达式的值。若表达式错误，则给出相应提示。为了简化设计，现做以下规定： 1）键盘输入的表达式中的数据都只有个位，不考虑多位的情况； 2）任何运算结果都是整数，不考虑小数情况；程序主要功能描述如下： 1) 从键盘上输入表达式。 2) 分析该表达式是否合法： ①是数字，则判断该数字的合法性。若合法，则压入数据到堆栈 ②是规定的运算符，则根据规则进行处理。在处理过程中，将计算该表达式的值。 ③若是其它字符，则返回错误信息。 3) 若上述处理过程中没有发现错误，则认为该表达式合法，并输出处理结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;iostream&gt;#define True 11 #define False 0#define Ok 111#define Error -111#define Stack_Init_Size 10#define StackIncrement 10typedef int Status; //状态类型typedef int SElemType; //元素类型typedef struct &#123; SElemType* base; //动态空间基址 int top; //实际元素个数 int stacksize; //当前存储容量(以sizeof(ElemType)为单位)&#125;SqStack;Status InitStack(SqStack&amp; S) &#123; //分配空间 S.base = (SElemType*)malloc(sizeof(SElemType) * Stack_Init_Size); if (S.base == NULL) &#123; return Error; &#125; //初始化数值 S.top = 0; S.stacksize = Stack_Init_Size; return Ok;&#125;Status Push(SqStack&amp; S, SElemType e) &#123; //判断栈满 if (S.top == S.stacksize) &#123; return Error; &#125; //入栈 S.base[S.top++] = e; //top指向下一个空位 return Ok;&#125;Status Pop(SqStack&amp; S, SElemType&amp; e) &#123; //判断栈空 if (S.top == 0) &#123; return Error; &#125; //出栈 e = S.base[--S.top]; //top指向下一个空位 return Ok;&#125;SElemType GetTop(SqStack S) &#123; if (S.top != NULL) &#123; return S.base[--S.top]; &#125;&#125;int Operate(int a, int Operator, int b) &#123; switch (Operator) &#123; case 0: return a + b; break; case 1: return b - a; break; case 2: return a * b; break; case 3: return b / a; default: break; &#125;&#125;Status IsOperator(char c, int&amp; code) &#123; switch (c) &#123; case &apos;+&apos;: code = 0; return True; case &apos;-&apos;: code = 1; return True; case &apos;*&apos;: code = 2; return True; case &apos;/&apos;: code = 3; return True; case &apos;(&apos;: code = 4; return True; case &apos;)&apos;: code = 5; return True; case &apos;#&apos;: code = 6; return True; case &apos;0&apos;: code = 0; return False; case &apos;1&apos;: code = 1; return False; case &apos;2&apos;: code = 2; return False; case &apos;3&apos;: code = 3; return False; case &apos;4&apos;: code = 4; return False; case &apos;5&apos;: code = 5; return False; case &apos;6&apos;: code = 6; return False; case &apos;7&apos;: code = 7; return False; case &apos;8&apos;: code = 8; return False; case &apos;9&apos;: code = 9; return False; default: return Error; &#125;&#125;int Precede(int precode, int nextcode) &#123; int comp[7][7]&#123; &#123;1,1,-1,-1,-1,1,1&#125;, &#123;1,1,-1,-1,-1,1,1&#125;, &#123;1,1,1,1,-1,1,1&#125;, &#123;1,1,1,1,-1,1,1&#125;, &#123;-1,-1,-1,-1,-1,0,2&#125;, &#123;1,1,1,1,2,1,1&#125;, &#123;-1,-1,-1,-1,-1,2,0&#125; &#125;; return comp[precode][nextcode];&#125;int EvaluateExpression() &#123; SqStack OPND, OPTR; //OPND数字栈 OPTR运算符栈 char ch; //用户输入字符 int opat; //用户输入操作符转码 int theta; //栈顶弹出运算符转码 SElemType a, b; //操作数 //初始化栈 InitStack(OPND); InitStack(OPTR); printf(&quot;请输入表达式：&quot;); scanf_s(&quot;%c&quot;, &amp;ch); Push(OPTR,6); while (ch != &apos;#&apos; || GetTop(OPTR) != 6) &#123; //表达式没有扫描完毕或栈顶元素不为# if (!IsOperator(ch, opat)) &#123; //不是操作符，数字压入栈，读取下一个字符 Push(OPND, opat); scanf_s(&quot;%c&quot;, &amp;ch); &#125; else &#123; //是操作符,比较优先级 switch (Precede(GetTop(OPTR),opat)) &#123; case 1: //栈内优先级高，弹出两数运算，入栈 Pop(OPTR, theta); //弹出运算符 Pop(OPND, a); //弹出两数字 Pop(OPND, b); Push(OPND,Operate(a, theta, b)); //运算，入栈 break; case -1: //栈内优先级低，入栈，读取 Push(OPTR, opat); scanf_s(&quot;%c&quot;, &amp;ch); break; case 0: //栈顶为（，opat为） Pop(OPTR, a); scanf_s(&quot;%c&quot;, &amp;ch); break; default: return Error; &#125; &#125; &#125; return GetTop(OPND);&#125;int main(int argc, char argv[]) &#123; SqStack S; SElemType e = 3; /* printf(&quot;%d&quot;, InitStack(S)); printf(&quot;%d&quot;, Push(S, e)); printf(&quot;%d&quot;, GetTop(S)); printf(&quot;%d&quot;, Pop(S, e)); printf(&quot;%d&quot;, Operate(2, 0, 3)); */ printf(&quot;%d&quot;, EvaluateExpression()); return 0;&#125; 递归转栈已知函数t(n)=2*t(n/2)+n 其中t(0)=0，n为整数。编写程序实现：（1）计算t(n)的递归算法。（2）用栈实现计算t(n)的非递归算法。（建议用链式栈）编写主函数，输入n值，输出递归算法和非递归算法的计算结果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define Ok 1#define Error -1typedef int Status;typedef int ElemType;typedef struct StackNode &#123; ElemType data; struct StackNode* next;&#125;StackNode,*LinkStack;int t(int n) &#123; if (n == 0) &#123; return 0; &#125; else &#123; return 2 * t(n / 2) + n; &#125;&#125;//初始化链栈Status InitStack(LinkStack&amp; S) &#123; //构造空栈 S = NULL; return Ok;&#125;//入栈Status Push(LinkStack&amp; S, ElemType e) &#123; StackNode* p = (StackNode*)malloc(sizeof(StackNode)); p-&gt;data = e; p-&gt;next = S; S = p; return Ok;&#125;//出栈Status Pop(LinkStack&amp; S, ElemType&amp; e) &#123; StackNode* p; if (S == NULL) &#123; return Error; &#125; e = S-&gt;data; p = S; S = S-&gt;next; free(p); return Ok;&#125;ElemType GetTop(LinkStack S) &#123; if (S != NULL) &#123; return S-&gt;data; &#125;&#125;int Caculate(int n) &#123; int e; int result = 0; LinkStack S; InitStack(S); for (int i = n; i &gt; 0; i = i / 2) &#123; Push(S, i); &#125; while (S) &#123; result = 2 * result + GetTop(S); Pop(S, e); &#125; return result;&#125;int main(int argc, char argv[]) &#123; int a; printf(&quot;输入n：&quot;); scanf_s(&quot;%d&quot;, &amp;a); printf(&quot;递归结果：t(n)=%d\n&quot;, t(a)); printf(&quot;栈结果 ：t(n)=%d&quot;, Caculate(a));&#125; 顺序循环队列基本操作约瑟夫环问题：设有n个人围坐在圆桌周围，现从某个位置 i 上的人开始报数，数到 m 的人就站出来。下一个人，即原来的第m+1个位置上的人，又从1开始报数，再是数到m的人站出来。依次重复下去，直到全部的人都站出来，按出列的先后又可得到一个新的序列。由于该问题是由古罗马著名的史学家家Josephus提出的问题演变而来，所以通常称为Josephus问题。例如：当n=8, m=4, i=1时，得到出列序列为：4，8，5，2，1，3，7，6。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define True 11#define False 0#define Ok 111#define Error -111typedef int Status; //状态类型typedef int QElemType; //元素类型typedef struct&#123; QElemType* base; //动态存储空间首址 int front; //头下标，队头元素下标 int rear; //尾下标，队尾元素的下一个位置 int qsize; //队列占用的空间（以元素为单位）&#125;SqQueue;Status InitQueue(SqQueue &amp;Q, int size) &#123;// Q.base = (QElemType*)malloc(sizeof(QElemType) * (size + 1)); Q.base = new QElemType[size + 1]; if (Q.base == NULL) &#123; return Error; &#125; Q.front = 0; Q.rear = 0; Q.qsize = size + 1; //对size+1取模; return Ok;&#125;Status EnQueue(SqQueue&amp; Q, QElemType e) &#123; //判断队列满 if ((Q.rear + 1) % Q.qsize == Q.front) &#123; return Error; &#125; Q.base[Q.rear] = e; Q.rear = (Q.rear+1) % Q.qsize; return Ok;&#125;Status DeQueue(SqQueue&amp; Q, QElemType&amp; e) &#123; //判断队空 if (Q.front == Q.rear) &#123; return Error; &#125; e = Q.base[Q.front]; Q.front = (Q.front + 1) % Q.qsize; return Ok;&#125;Status QueueEmpty(SqQueue&amp; Q) &#123; if (Q.front == Q.rear) &#123; return True; &#125; return False;&#125;QElemType GetHead(SqQueue&amp; Q) &#123; if (!QueueEmpty(Q)) &#123; return Q.base[Q.front]; &#125;&#125;Status Circle(int n, int i, int m) &#123; SqQueue Q; QElemType e; int cnt = 0; InitQueue(Q, n); for (int j = 1; j &lt;= n; j++) &#123; EnQueue(Q, j); &#125; for (int j = 0; j &lt; i - 1; j++) &#123; DeQueue(Q, e); EnQueue(Q, e); &#125; while (!QueueEmpty(Q)) &#123; cnt++; if (cnt != m) &#123; DeQueue(Q, e); EnQueue(Q, e); &#125; else &#123; DeQueue(Q, e); printf(&quot;%d &quot;, e); cnt = 0; &#125; &#125; return Ok;&#125;int main(int argv, char argc[]) &#123; SqQueue Q; Q.base = NULL; int size = 9; QElemType e = 5; /* InitQueue(Q, size); EnQueue(Q, 5); EnQueue(Q, 7); EnQueue(Q, 6); DeQueue(Q, e); printf(&quot;%d&quot;, e); DeQueue(Q, e); printf(&quot;%d&quot;, e); DeQueue(Q, e); printf(&quot;%d&quot;, e); */ Circle(8, 1, 4); printf(&quot;\n&quot;); Circle(9, 3, 4); printf(&quot;\n&quot;); Circle(19, 5, 3); return 0;&#125; 二叉树的建立及遍历二叉树的创建编写程序任意输入二叉树的结点个数和结点值，构造一棵二叉树，采用三种递归遍历算法(前序、中序、后序)对这棵二叉树进行遍历，并计算出二叉树的高度、叶子结点数以及总结点数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116typedef char ElemType;typedef struct BiTNode &#123; ElemType data; BiTNode* lchild; BiTNode* rchild;&#125;BiTNode, *BiTree;//创建二叉树void CreateBiTree(BiTree &amp;T) &#123; ElemType ET; ET = cin.get(); if (ET == &apos; &apos;) &#123; T = NULL; &#125; else &#123; //生成根节点 T = (BiTree)malloc(sizeof(BiTNode)); if (T == NULL) &#123; cout &lt;&lt; &quot;内存分配失败！&quot; &lt;&lt; endl; &#125; T-&gt;data = ET; CreateBiTree(T-&gt;lchild); CreateBiTree(T-&gt;rchild); &#125;&#125;//打印元素ElemType PrintElement(ElemType e) &#123; cout &lt;&lt; e &lt;&lt; &quot; &quot;; return e;&#125;//先序遍历void PreOrderTraverse(BiTree T) &#123; if (T != NULL) &#123; PrintElement(T-&gt;data); PreOrderTraverse(T-&gt;lchild); PreOrderTraverse(T-&gt;rchild); &#125;&#125;//中序遍历void InOrderTraverse(BiTree T) &#123; if (T != NULL) &#123; PreOrderTraverse(T-&gt;lchild); PrintElement(T-&gt;data); PreOrderTraverse(T-&gt;rchild); &#125;&#125;//后序遍历void PostOrderTraverse(BiTree T) &#123; if (T != NULL) &#123; PreOrderTraverse(T-&gt;lchild); PreOrderTraverse(T-&gt;rchild); PrintElement(T-&gt;data); &#125;&#125;//深度int Depth(BiTree&amp; T) &#123; if (T == NULL) &#123; return 0; &#125; int m = Depth(T-&gt;lchild); int n = Depth(T-&gt;rchild); if (m &gt; n) &#123; return m + 1; &#125; else &#123; return n + 1; &#125;&#125;//节点个数int NodeCount(BiTree&amp; T) &#123; if (T == NULL) &#123; return 0; &#125; else return NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild) + 1;&#125;//叶子节点个数int CountLeaf(BiTree&amp; T) &#123; if (T == NULL) &#123; return 0; &#125; if (T-&gt;lchild == NULL &amp;&amp; T-&gt;rchild == NULL) &#123; return 1; &#125; return CountLeaf(T-&gt;rchild) + CountLeaf(T-&gt;lchild);&#125;int main(int argc, char argv[]) &#123; BiTree T; cout &lt;&lt; &quot;先序创建二叉树：&quot;; CreateBiTree(T); cout &lt;&lt; &quot;先序遍历：&quot;; PreOrderTraverse(T); cout &lt;&lt; endl; cout &lt;&lt; &quot;中序遍历：&quot;; InOrderTraverse(T); cout &lt;&lt; endl; cout &lt;&lt; &quot;后序遍历：&quot;; PostOrderTraverse(T); cout &lt;&lt; endl; cout &lt;&lt; &quot;深度：&quot;; cout &lt;&lt; Depth(T) &lt;&lt; endl; cout &lt;&lt; &quot;节点个数：&quot;; cout &lt;&lt; NodeCount(T) &lt;&lt; endl; cout &lt;&lt; &quot;叶子节点个数：&quot;; cout &lt;&lt; CountLeaf(T) &lt;&lt; endl; return 0;&#125; 二叉树非递归遍历编写程序生成下面所示的二叉树，并采用中序遍历的非递归算法对此二叉树进行遍历。二叉树：”12 346 5 “ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;iostream&gt;using namespace std;#define True 1#define False -1#define Ok 11#define Error -11typedef int Status;typedef char ElemType;typedef struct BiTNode &#123; ElemType Data; BiTNode* lchild; BiTNode* rchild;&#125;BiTNode, * BiTree;typedef BiTNode* StackElem;typedef struct Stack &#123; StackElem* Data; int StackSize; int Top; int Base;&#125;SqStack;//初始化栈Status InitStack(SqStack&amp; S) &#123; S.Data = (StackElem*)malloc(10 * sizeof(StackElem)); S.StackSize = 10; S.Base = 0; S.Top = 0; return Ok;&#125;Status Push(SqStack&amp; S, StackElem e) &#123; if (S.Top + 1 == S.StackSize) &#123; return Error; &#125; else &#123; S.Data[S.Top] = e; S.Top++; return Ok; &#125;&#125;Status Pop(SqStack&amp; S, StackElem&amp; e) &#123; if (S.Base == S.Top) &#123; return Error; &#125; else &#123; e = S.Data[--S.Top]; return Ok; &#125;&#125;bool StackEmpty(SqStack S) &#123; if (S.Base == S.Top) &#123; return true; &#125; return false;&#125;//创建二叉树void CreateBiTree(BiTree&amp; T) &#123; ElemType ET; ET = cin.get(); if (ET == &apos; &apos;) &#123; T = NULL; &#125; else &#123; T = (BiTree)malloc(sizeof(BiTNode)); if (T == NULL) &#123; cout &lt;&lt; &quot;分配内存失败！&quot; &lt;&lt; endl; &#125; T-&gt;Data = ET; CreateBiTree(T-&gt;lchild); CreateBiTree(T-&gt;rchild); &#125;&#125;//打印节点元素ElemType PrintElement(ElemType e) &#123; cout &lt;&lt; e &lt;&lt; &apos; &apos;; return e;&#125;//中序遍历递归算法void InOrderTraverse(BiTree T) &#123; if (T != NULL) &#123; InOrderTraverse(T-&gt;lchild); PrintElement(T-&gt;Data); InOrderTraverse(T-&gt;rchild); &#125;&#125;//中序遍历非递归算法void Traverse(BiTree T) &#123; SqStack S; InitStack(S); BiTNode* p = T; BiTNode* q; while (p || !StackEmpty(S)) &#123; if (p) &#123; Push(S, p); p = p-&gt;lchild; &#125; else &#123; Pop(S, q); cout &lt;&lt; q-&gt;Data &lt;&lt; &apos; &apos;; p = q-&gt;rchild; &#125; &#125;&#125;//12 346 5 int main(int argc, char argv[]) &#123; BiTree T; cout &lt;&lt; &quot;创建二叉树：&quot;; CreateBiTree(T); cout &lt;&lt; &quot;中序递归算法：&quot;; InOrderTraverse(T); cout &lt;&lt; endl; cout &lt;&lt; &quot;中序非递归算法：&quot;; Traverse(T); cout &lt;&lt; endl; return 0;&#125; 哈夫曼树基于哈夫曼树的数据压缩算法输入一串字符串，根据给定的字符串中字符出现的频率建立相应的哈夫曼树，构造哈夫曼编码表，在此基础上对字符串进行压缩（即编码），同时对压缩后的二进制编码文件进行解压（即译码）。为简化设计，输入字符串均为小写英文字母，要求输出:①统计的字符出现频率（输出格式为 “字符:频度”）②哈夫曼树构造过程，用哈夫曼树的存储结构的终态表示（参见教材p139）③字符串的编码④解码的字符串编程提示：问题可分解为3个部分（1） 读入字符串，统计每个字符出现的频度；（2） 根据出现的频度利用算法5.10（参见教材p138）建立哈夫曼树（3） 根据得到的哈夫曼树利用算法5.11（参见教材p141）求出每个字符的哈夫曼编码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include&lt;iostream&gt;#include&lt;string&gt;#pragma warning(disable : 4996)using namespace std;//哈夫曼树结点typedef struct &#123; int weight; //结点权值 int parent, lchild, rchild; //结点双亲、左孩子、右孩子下标&#125;HTNode, *HuffmanTree;//哈夫曼编码typedef char* HuffmanCode;//字符串频率、编码表typedef struct &#123; char type; //字符类型 int nums; //个数 HuffmanCode HC;&#125;Char_Num, *Char_Num_Table;void PrintHT(HuffmanTree HT, int n);void CreateHuffmanTree(HuffmanTree&amp; HT, int n, Char_Num_Table CNT);void Select(HuffmanTree&amp; HT, int nums, int&amp; s1, int&amp; s2);int CountStr(string str, int* cnt);void RecordCNT(int cnt[], int num, Char_Num_Table&amp; CNT);void CreateHuffmanCode(HuffmanTree HT, Char_Num_Table&amp; CNT, int n);void PrintHuffmanCode(Char_Num_Table CNT, int n);string PrintStrCode(string str, Char_Num_Table CNT, int n);string StrDecode(Char_Num_Table CNT, int n, string code);int main(int argc, char argv[]) &#123; int cnt[28] = &#123;0&#125;; //下标1为a，2为b类推。数值为个数。 string str; //输入字符串 string code; //编码 string destr; //解码 HuffmanTree HT; int num = 0; //结点个数 Char_Num_Table CNT; //构造哈夫曼树 cout &lt;&lt; &quot;请输入字符串（均为小写字母）&quot;; getline(cin, str); num = CountStr(str, cnt); RecordCNT(cnt, num, CNT); cout &lt;&lt; endl &lt;&lt;&quot;哈夫曼树下标对应字符：&quot; &lt;&lt; endl; for (int i = 1; i &lt;= num; i++) &#123; cout&lt;&lt;&quot;node &quot;&lt;&lt;i&lt;&lt;&quot;\t=\t&quot;&lt;&lt;CNT[i].type&lt;&lt; endl; &#125; cout &lt;&lt; endl; CreateHuffmanTree(HT, num, CNT); //哈夫曼编码 CreateHuffmanCode(HT, CNT, num); cout &lt;&lt; endl &lt;&lt; &quot;哈夫曼编码：&quot; &lt;&lt; endl; PrintHuffmanCode(CNT, num); cout &lt;&lt; endl &lt;&lt; &quot;字符串编码：&quot; &lt;&lt; endl; code = PrintStrCode(str, CNT, num); cout &lt;&lt; code; //哈夫曼解码 cout &lt;&lt; endl &lt;&lt; &quot;哈夫曼解码：&quot; &lt;&lt; endl; destr = StrDecode(CNT, num, code); cout &lt;&lt; destr; return 0;&#125;void CreateHuffmanTree(HuffmanTree&amp; HT, int n, Char_Num_Table CNT) &#123; //一个叶子结点,有效性判断 if (n &lt;= 1) &#123; return; &#125; //哈夫曼树的结点个数 int m = 2 * n - 1; //下标为0不用 HT = new HTNode[m + 1]; for (int i = 1; i &lt;= m; i++) &#123; HT[i].parent = 0; HT[i].lchild = 0; HT[i].rchild = 0; HT[i].weight = 0; &#125; //初始化权值 for (int i = 1; i &lt;= n; i++) &#123; HT[i].weight = CNT[i].nums; &#125; //打印初态 PrintHT(HT, n); cout &lt;&lt; endl; //贪心构造哈夫曼树 for (int i = n + 1; i &lt;= m; i++) &#123; int s1, s2; Select(HT, i - 1, s1, s2); HT[s1].parent = i; HT[s2].parent = i; HT[i].lchild = s1; HT[i].rchild = s2; HT[i].weight = HT[s1].weight + HT[s2].weight; &#125; PrintHT(HT, n);&#125;//选择结点，记录最小权值的两个结点下标void Select(HuffmanTree&amp; HT, int nums, int&amp; s1, int&amp; s2) &#123; HTNode temp; int minWeight = INT_MAX; for (int i = 1; i &lt;= nums; i++) &#123; if (HT[i].parent != 0) &#123; continue; &#125; else&#123; temp = HT[i]; &#125; if (minWeight &gt; temp.weight) &#123; minWeight = temp.weight; s1 = i; &#125; &#125; minWeight = INT_MAX; for (int i = 1; i &lt;= nums; i++) &#123; if (HT[i].parent != 0 || i == s1) &#123; continue; &#125; else&#123; temp = HT[i]; &#125; if (minWeight &gt; temp.weight) &#123; minWeight = temp.weight; s2 = i; &#125; &#125;&#125;int CountStr(string str, int* cnt)&#123; int num = 0; for (int i = 0; i &lt; str.size(); i++) &#123; cnt[((int)str[i] - 96)]++; &#125; cout &lt;&lt; &quot;字符\t:\t频率&quot; &lt;&lt; endl; for (int i = 1; i &lt;= 26; i++) &#123; if (cnt[i] != 0) &#123; cout &lt;&lt; (char)(i + 96) &lt;&lt; &quot;\t:\t&quot; &lt;&lt; cnt[i] &lt;&lt; endl; num++; &#125; &#125; return num;&#125;void RecordCNT(int cnt[], int num, Char_Num_Table&amp; CNT)&#123; int insert = 1; CNT = new Char_Num[num+1]; for (int i = 1; i &lt;= 26; i++) &#123; if (cnt[i] != 0) &#123; CNT[insert].type = (char)(i + 96); CNT[insert].nums = cnt[i]; insert++; &#125; &#125;&#125;void CreateHuffmanCode(HuffmanTree HT, Char_Num_Table&amp; CNT, int n)&#123; char* cd = new char[n]; cd[n - 1] = &apos;\0&apos;; for (int i = 1; i &lt;= n; i++) &#123; int start = n - 1; int node = i; int parent = HT[i].parent; while (parent != 0) &#123; --start; if (node == HT[parent].lchild) &#123; cd[start] = &apos;0&apos;; &#125; else &#123; cd[start] = &apos;1&apos;; &#125; node = parent; parent = HT[parent].parent; &#125; CNT[i].HC = new char[n - start]; strcpy(CNT[i].HC, &amp;cd[start]); &#125; delete[] cd;&#125;void PrintHT(HuffmanTree HT, int n) &#123; cout &lt;&lt; &quot;node\t|weight\t|parent\t|lchild\t|rchild&quot; &lt;&lt; endl; for (int i = 1; i &lt; 2*n; i++) &#123; cout &lt;&lt; i &lt;&lt; &quot;\t|&quot; &lt;&lt; HT[i].weight &lt;&lt; &quot;\t|&quot; &lt;&lt; HT[i].parent &lt;&lt; &quot;\t|&quot; &lt;&lt; HT[i].lchild &lt;&lt; &quot;\t|&quot; &lt;&lt; HT[i].rchild &lt;&lt; endl; &#125;&#125;void PrintHuffmanCode(Char_Num_Table CNT, int num) &#123; cout &lt;&lt; &quot;字符\t|\t编码&quot; &lt;&lt; endl; for (int i = 1; i &lt;= num; i++) &#123; cout &lt;&lt; CNT[i].type &lt;&lt; &quot;\t|\t&quot; &lt;&lt; CNT[i].HC &lt;&lt; endl; &#125;&#125;string PrintStrCode(string str,Char_Num_Table CNT, int n) &#123; string code = &quot;&quot;; for (int i = 0; i &lt; str.size(); i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (str[i] == CNT[j].type) &#123; code = code + (string)CNT[j].HC;// cout &lt;&lt; CNT[j].HC; &#125; &#125; &#125; return code;&#125;string StrDecode(Char_Num_Table CNT, int n, string code) &#123; string temp = &quot;&quot;; //临时串 string str = &quot;&quot;; //解码后的字符串 int c = 0; //code下标 for (int i = 0; i &lt; code.size(); i++) &#123; temp = temp + code[i]; for (int j = 1; j &lt;= n; j++) &#123; if (temp == (string)CNT[j].HC) &#123; str = str + CNT[j].type; temp = &quot;&quot;; break; &#125; &#125; &#125; return str;&#125; 查找算法的实现Hash查找算法编写程序实现Hash表的建立、删除、插入以及查找操作。程序应包含的主要功能函数有：Hash( )：计算哈希地址InitialHash( )：初始化哈希表SearchHash( )：在哈希表中查找关键字InsertHash( )：向哈希表中插入关键字DeleteHash( )：删除哈希表中某一关键字PrintHash ( )：打印输出哈希表设计函数原型，实现各函数功能，并编写main函数对函数实现情况加以测试。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis-笔记]]></title>
    <url>%2F2019%2F11%2F17%2FMybatis-%E9%BB%91%E9%A9%AC%2F</url>
    <content type="text"><![CDATA[ORM思想Object Relational Mapping 对象关系映射。把数据库表和实体类及实体类的属性对应起来，通过操作实体类从而操作数据库表。 环境搭建1、创建一个maven工程2、导入坐标 1)mybatis 2)mysql 3)log4j(日志部分) 4)junit(测试)3、创建实体类和Dao接口4、创建Mybatis主配置文件 SqlMapConfig.xml5、创建映射配置文件 导入坐标123456789101112131415161718192021222324&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.18&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; log4j123456789101112131415161718# Set root category priority to INFO and its only appender to CONSOLE.#log4j.rootCategory=INFO, CONSOLE debug info warn error fatallog4j.rootCategory=debug, CONSOLE, LOGFILE# Set the enterprise logger category to FATAL and its only appender to CONSOLE.log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE# CONSOLE is set to be a ConsoleAppender using a PatternLayout.log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n# LOGFILE is set to be a File appender using a PatternLayout.log4j.appender.LOGFILE=org.apache.log4j.FileAppenderlog4j.appender.LOGFILE.File=d:\axis.loglog4j.appender.LOGFILE.Append=truelog4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayoutlog4j.appender.LOGFILE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n 配置文件主配置文件SqlMapConfig.xml1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default=&quot;mysql&quot;&gt; &lt;!-- 配置mysql的环境 --&gt; &lt;environment id=&quot;mysql&quot;&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源（连接池）--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;password&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定映射配置文件的位置（每个dao独立的配置文件） --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;dao/IUserDao.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 映射配置文件12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;dao.IUserDao&quot;&gt; &lt;!--配置查询所有--&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;domain.User&quot;&gt; select * from user; &lt;/select&gt;&lt;/mapper&gt; 入门案例XML配置过程1、读取配置文件2、创建SqlSessionFactory工厂3、创建SqlSession4、创建Dao接口的代理对象5、执行dao中的方法6、释放资源 12345678910111213141516171819public static void main(String[] args)throws Exception &#123; //读取配置文件 InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(in); //使用工厂生产SqlSession对象 SqlSession session = factory.openSession(); //SqlSession session = factory.openSession(true); 事务自动提交 //使用SqlSession创建Dao接口的代理对象 IUserDao userDao = session.getMapper(IUserDao.class); //使用代理对象执行方法 List&lt;User&gt; users = userDao.findAll(); for(User user : users)&#123; System.out.println(user); &#125; //释放资源 session.close(); in.close();&#125; 注解配置1、Dao中添加注解2、mapper使用class属性 1234public interface IUserDao &#123; @Select(&quot;select * from user&quot;) List&lt;User&gt; findAll();&#125; 1234&lt;mappers&gt;&lt;!-- &lt;mapper resource=&quot;dao/IUserDao.xml&quot;/&gt;--&gt; &lt;mapper class=&quot;dao.IUserDao&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt; 设计模式分析1234567891011121314151617181920212223242526272829303132333435public static void main(String[] args)throws Exception &#123; //读取配置文件 /* 法一：使用类加载器，他只能读取类路径的配置文件。 法二：使用ServletContext对象的getRealPath() */ InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //创建SqlSessionFactory工厂 /* 创建工厂使用了 构建者模式 把对象的创建细节隐藏，使使用者直接调用方法即可拿到对象 */ SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); /* 生产SqlSession使用了 工厂模式 解耦，降低类之间的依赖关系 */ SqlSessionFactory factory = builder.build(in); //使用工厂生产SqlSession对象 SqlSession session = factory.openSession(); //使用SqlSession创建Dao接口的代理对象 /* 创建Dao接口实现类使用了代理模式 不修改源码的基础上对已有方法增强 */ IUserDao userDao = session.getMapper(IUserDao.class); //使用代理对象执行方法 List&lt;User&gt; users = userDao.findAll(); for(User user : users)&#123; System.out.println(user); &#125; //释放资源 session.close(); in.close();&#125; Mybatis的CURD操作Dao接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package dao;import domain.QueryVo;import domain.User;import java.util.List;public interface IUserDao &#123; /** * 查询所有 * @return */// @Select(&quot;select * from user&quot;) List&lt;User&gt; findAll(); /** * 保存用户 * @param user */ void saveUser(User user); /** * 更新用户 * @param user */ void updateUser(User user); /** * 删除用户 * @param id */ void deleteUser(int id); /** * 查询一个 * @param id * @return */ User findById(int id); /** * 模糊查询 * @param username * @return */ List&lt;User&gt; findByName(String username); /** * 查询总用户数 * @return */ int findTotal(); /** * 根据vo中的条件查询用户 * @param vo * @return */ List&lt;User&gt; findByVo(QueryVo vo);&#125; Dao接口对应XML文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;dao.IUserDao&quot;&gt; &lt;!--配置查询所有--&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;domain.User&quot;&gt; select * from user; &lt;/select&gt; &lt;!-- 保存 --&gt; &lt;insert id=&quot;saveUser&quot; parameterType=&quot;domain.User&quot;&gt; &lt;!-- 获得保存的ID值 --&gt; &lt;selectKey keyProperty=&quot;id&quot; keyColumn=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt; select last_insert_id(); &lt;/selectKey&gt; insert into user(username, address, sex, birthday) values (#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;); &lt;/insert&gt; &lt;!-- 更新 --&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;domain.User&quot;&gt; update user set username = #&#123;username&#125;, address = #&#123;address&#125;, sex = #&#123;sex&#125;, birthday = #&#123;birthday&#125; where id = #&#123;id&#125;; &lt;/update&gt; &lt;!-- 删除 --&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from user where id = #&#123;id&#125;; &lt;/delete&gt; &lt;!-- 查询一个--&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;domain.User&quot;&gt; select * from user where id = #&#123;id&#125;; &lt;/select&gt; &lt;!-- 模糊查询 --&gt; &lt;select id=&quot;findByName&quot; parameterType=&quot;String&quot; resultType=&quot;domain.User&quot;&gt; select * from user where username like #&#123;username&#125;; &lt;/select&gt; &lt;!--统计个数--&gt; &lt;select id=&quot;findTotal&quot; resultType=&quot;int&quot;&gt; select count(id) from user; &lt;/select&gt; &lt;!--实体类包装对象查询--&gt; &lt;select id=&quot;findByVo&quot; parameterType=&quot;domain.QueryVo&quot; resultType=&quot;domain.User&quot;&gt; select * from user where username like #&#123;user.username&#125;; &lt;/select&gt;&lt;/mapper&gt; 测试文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package domain;public class MybatisTest &#123; InputStream in = null; SqlSession session = null; IUserDao userDao = null; @Before public void init() throws Exception &#123; //读取配置文件 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //创建SqlSessionFactory工厂 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //使用工厂生产SqlSession对象 session = factory.openSession(); //使用SqlSession创建Dao接口的代理对象 userDao = session.getMapper(IUserDao.class); &#125; @After public void destory() throws IOException &#123; session.commit(); //释放资源 session.close(); in.close(); &#125; @Test public void testFindAll() &#123; //使用代理对象执行方法 List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println(user); &#125; &#125; /** * 测试保存操作 */ @Test public void testSave() &#123; User user = new User(); user.setUsername(&quot;mybatis&quot;); user.setAddress(&quot;北京市&quot;); user.setSex(&quot;男&quot;); user.setBirthday(new Date()); System.out.println(user); userDao.saveUser(user); System.out.println(user); &#125; @Test public void testUpdate() &#123; User user = new User(); user.setUsername(&quot;mybatis1&quot;); user.setAddress(&quot;北京市&quot;); user.setSex(&quot;女&quot;); user.setBirthday(new Date()); user.setId(51); userDao.updateUser(user); &#125; @Test public void testDelete() &#123; userDao.deleteUser(51); &#125; @Test public void testFindOne() &#123; User user = userDao.findById(48); System.out.println(user); &#125; @Test public void testFindByName() &#123; List&lt;User&gt; users = userDao.findByName(&quot;%王%&quot;); for (User user : users) &#123; System.out.println(user); &#125; &#125; @Test public void testFindTotal() &#123; System.out.println(userDao.findTotal()); &#125; @Test public void testFindByVo() &#123; QueryVo vo = new QueryVo(); User user = new User(); user.setUsername(&quot;%王%&quot;); vo.setUser(user); List&lt;User&gt; users = userDao.findByVo(vo); for (User u : users) &#123; System.out.println(u); &#125; &#125;&#125; 配置查询结果列名和实体类属性名对应关系123456789101112131415&lt;resultMap id=&quot;userMap&quot; type=&quot;domain.User&quot;&gt; &lt;!-- 主键字段的对应 --&gt; &lt;id property=&quot;userId&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;!-- 非主键字段对应 --&gt; &lt;result property=&quot;userName&quot; column=&quot;username&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userAddress&quot; column=&quot;address&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userSex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userBirthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;//再调用resultMap属性调用关系映射&lt;!--配置查询所有--&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt; select * from user; &lt;/select&gt; 配置 properties在标签内部配置数据库信息1234567891011121314&lt;properties&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;password&quot;/&gt;&lt;/properties&gt;&lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;&lt;/dataSource&gt; 1234567&lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;password&quot;/&gt;&lt;/dataSource&gt; 引用外部文件信息12345//外部配置文件driver=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTCusername=rootpassword=password 12345678910&lt;properties url:&quot;外部配置文件URL&quot;&gt;&lt;/properties&gt;&lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;password&quot;/&gt;&lt;/dataSource&gt; Aliases 标签主配置文件：123&lt;typeAliases&gt; &lt;typeAlias type=&quot;dao.IUserDao&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt;&lt;/typeAliases&gt; 使用别名：1234567&lt;insert id=&quot;saveUser&quot; parameterType=&quot;User&quot;&gt;&lt;!-- 获得保存的ID值 --&gt;&lt;selectKey keyProperty=&quot;id&quot; keyColumn=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt; select last_insert_id();&lt;/selectKey&gt; insert into user(username, address, sex, birthday) values (#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;);&lt;/insert&gt; 连接池mybatis连接池提供3种方式配置：1、POOLED 采用传统的javax.sql.DataSource规范中的连接池，mybatis中有针对规范的实现。（使用池）2、UNPOOLED 采用传统的获取连接的方式，虽然也实现了javax.sql.DataSource接口，但是并没有使用池的思想。3、JNDI 采用服务器提供的JNDI技术实现，来获取DataSource对象，不同的服务器能拿到的DataSource时不一样的。 动态sql语句if 标签123456789101112131415161718192021222324252627//IUserDao /** * 条件查找 * @param user * @return */ List&lt;User&gt; findByCondition(User user);//IUserDao.xml&lt;select id=&quot;findByCondition&quot; parameterType=&quot;domain.User&quot; resultType=&quot;domain.User&quot;&gt; select * from user where 1=1 &lt;if test=&quot;username != null&quot;&gt; and username = #&#123;username&#125; &lt;/if&gt;&lt;/select&gt;//TestMybatis@Testpublic void testFindByCondition()&#123; User u = new User(); u.setUsername(&quot;老王&quot;); List&lt;User&gt; users = userDao.findByCondition(u); for(User user : users)&#123; System.out.println(user); &#125;&#125; where标签1234567891011&lt;select id=&quot;findByCondition&quot; parameterType=&quot;domain.User&quot; resultType=&quot;domain.User&quot;&gt; select * from user &lt;where&gt; &lt;if test=&quot;username != null&quot;&gt; and username = #&#123;username&#125; &lt;/if&gt; &lt;if test=&quot;sex != null&quot;&gt; and sex = #&#123;sex&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; foreach 标签collections:集合open:查询close:关闭item:东西separator:分隔符12345678&lt;select id=&quot;findByIds&quot; parameterType=&quot;domain.IdList&quot; resultType=&quot;domain.User&quot;&gt; select * from user &lt;where&gt; &lt;foreach collection=&quot;ids&quot; open=&quot;and id in (&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 多表查询一对一，建立实体类关系首先在Account类中添加User类，提供getter，setter。12345678910//从表实体包含一个主表实体的对象引用 private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; IAccountDao.xml 中，定义封装account和user的resultMap。12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;dao.IAccountDao&quot;&gt; &lt;resultMap id=&quot;accountUserMap&quot; type=&quot;domain.Account&quot;&gt; &lt;id property=&quot;ID&quot; column=&quot;aid&quot;&gt;&lt;/id&gt; //property是pojo中的 &lt;result property=&quot;UID&quot; column=&quot;uid&quot;&gt;&lt;/result&gt; &lt;result property=&quot;MONEY&quot; column=&quot;money&quot;&gt;&lt;/result&gt; &lt;!-- 一对一关系映射，配置封装User的内容 --&gt; &lt;association property=&quot;user&quot; column=&quot;uid&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt; &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!--配置查询所有--&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;accountUserMap&quot;&gt; select u.*, a.id as aid, a.uid, a.money from account a, user u where a.uid = u.id; &lt;/select&gt;&lt;/mapper&gt; 一对多User类中添加集合12345678910//一对多关系映射：主表实体应该包含从表实体的集合引用private List&lt;Account&gt; accounts;public List&lt;Account&gt; getAccounts() &#123; return accounts;&#125;public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts;&#125; IUserDao.xml 中，配置ResultMap123456789101112131415161718192021&lt;mapper namespace=&quot;com.itheima.dao.IUserDao&quot;&gt;&lt;!-- 定义User的resultMap--&gt;&lt;resultMap id=&quot;userAccountMap&quot; type=&quot;user&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt; &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;!-- 配置user对象中accounts集合的映射 --&gt; &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot;&gt; &lt;id column=&quot;aid&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;uid&quot; property=&quot;uid&quot;&gt;&lt;/result&gt; &lt;result column=&quot;money&quot; property=&quot;money&quot;&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- 查询所有 --&gt;&lt;select id=&quot;findAll&quot; resultMap=&quot;userAccountMap&quot;&gt; select * from user u left outer join account a on u.id = a.uid&lt;/select&gt; 注解开发pojo与数据库名不一致的解决 @Results123456789@Select(&quot;select * from user&quot;)@Results(id = &quot;userMap&quot;, value = &#123; //resultMap的id，实现复用 @Result(id = &quot;true&quot;, column = &quot;id&quot;, property = &quot;userId&quot;), //id属性 @Result(column = &quot;Address&quot;, property = &quot;userAddress&quot;), @Result(column = &quot;sex&quot;, property = &quot;userSex&quot;)&#125;)List&lt;User&gt; findAll();@ResultMap(value=&#123;&quot;userMap&quot;&#125;) //调用userMap 或 @ResultMap(&quot;userMap&quot;) 一对一注解select : 全限定方法名fetchType： 加载方法12345678910public interface IAccountDao &#123; @Select(&quot;select * from account&quot;) @Results(id = &quot;accountMap&quot;, value = &#123; @Result(id = true, column = &quot;id&quot;, property = &quot;id&quot;), @Result(column = &quot;uid&quot;, property = &quot;uid&quot;), @Result(column = &quot;money&quot;, property = &quot;money&quot;), @Result(column = &quot;uid&quot;, property = &quot;user&quot;, one = @One(select = &quot;dao.IUserDao.findById&quot;, fetchType = FetchType.EAGER)) //one属性 &#125;) List&lt;Account&gt; findAll();&#125; 1234567public interface IUserDao &#123; @Select(&quot;select * from user&quot;) List&lt;User&gt; findAll(); @Select(&quot;select * from user where id = #&#123;id&#125;&quot;) User findById();&#125; 一对多注解1234567891011121314151617public interface IUserDao &#123; @Select(&quot;select * from user&quot;) @Results(id = &quot;userMap&quot;, value = &#123; @Result(id = true, column = &quot;id&quot;, property = &quot;id&quot;), @Result(column = &quot;username&quot;, property = &quot;username&quot;), @Result(column = &quot;address&quot;, property = &quot;address&quot;), @Result(column = &quot;sex&quot;, property = &quot;sex&quot;), @Result(column = &quot;birthday&quot;, property = &quot;birthday&quot;), @Result(property = &quot;accounts&quot;, column = &quot;id&quot;, many = @Many(select = &quot;dao.IAccountDao.findById&quot;, fetchType = FetchType.LAZY)) &#125;) List&lt;User&gt; findAll(); @Select(&quot;select * from user where id = #&#123;id&#125;&quot;) User findById(int id);&#125; 12345678910111213public interface IAccountDao &#123; @Select(&quot;select * from account&quot;) @Results(id = &quot;accountMap&quot;, value = &#123; @Result(id = true, column = &quot;id&quot;, property = &quot;id&quot;), @Result(column = &quot;uid&quot;, property = &quot;uid&quot;), @Result(column = &quot;money&quot;, property = &quot;money&quot;), @Result(column = &quot;uid&quot;, property = &quot;user&quot;, one = @One(select = &quot;dao.IUserDao.findById&quot;, fetchType = FetchType.EAGER)) &#125;) List&lt;Account&gt; findAll(); @Select(&quot;select * from account where uid = #&#123;uid&#125;&quot;) List&lt;Account&gt; findById(int uid);&#125;]]></content>
      <categories>
        <category>Java知识体系</category>
      </categories>
      <tags>
        <tag>Java知识体系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页添加背景图片]]></title>
    <url>%2F2019%2F07%2F06%2F%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[为网页添加背景图片 1234body &#123; margin: 0; background-image: url(&quot;../img/backgroundImg.jpg&quot;);&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[只出现一次数字]]></title>
    <url>%2F2019%2F06%2F30%2F%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1]输出: 1示例 2: 输入: [4,1,2,1,2]输出: 4 解答利用异或运算来进行判断。通过0 ^ num = num, num ^ num = 0可知，重复两次的数字异或为0。而剩下的就是不重复数字的值。 1234567public int singleNumber(int[] nums) &#123; int num = 0; for(int i = 0; i &lt; nums.length; i++)&#123; num = num ^ nums[i]; &#125; return num;&#125; 异或对于一个数的每一个位上（二进制），数字相同则该位为0，不同则该位为1。 运算法则：1、a ^ a = 02、a ^ b = b ^ a3、a ^ b ^ c = a ^ (b ^ c)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存在重复]]></title>
    <url>%2F2019%2F06%2F30%2F%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[题目来自Leecode给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例 1: 输入: [1,2,3,1]输出: true示例 2: 输入: [1,2,3,4]输出: false示例 3: 输入: [1,1,1,3,3,4,3,2,4,2]输出: true 解答一：使用两个数组下标分辨遍历比较数组。12345678910public boolean containsDuplicate(int[] nums) &#123; for(int prev = 0; prev &lt; nums.length-1; prev++)&#123; for(int last = prev + 1; last &lt; nums.length; last++)&#123; if(nums[prev] == nums[last])&#123; return true; &#125; &#125; &#125; return false;&#125; 因为双重循环，效率并不高。 解答二：使用HashMap，将数组中的数一一放入HashMap里，若无法放入，则存在重复，只需要遍历一遍数组，效率较高。123456789101112public boolean containsDuplicate(int[] nums)&#123; if(nums == null || nums.length &lt;= 1)&#123; return false; &#125; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); for(int i = 0; i &lt; nums.length; i++)&#123; if(map.put(nums[i],i) != null)&#123; return true; &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2019%2F06%2F13%2FMySQL%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[MySQL基本使用MySQL启动启动本地MySQL：1net start mysql MySQL登录登录本机的MySQL：1mysql -u root -p 再输入MySQL的密码。 增、删、改。增加信息1insert into test values(); 删除信息1delete from test where id = 1; 修改信息 1update test set name = &apos;name1&apos; where id = 1; 查询信息1234567891011String sql = &quot;select * from hero&quot;;// 执行查询语句，并把结果集返回给ResultSetResultSet rs = s.executeQuery(sql);while (rs.next()) &#123; int id = rs.getInt(&quot;id&quot;);// 可以使用字段名 String name = rs.getString(2);// 也可以使用字段的顺序 float hp = rs.getFloat(&quot;hp&quot;); int damage = rs.getInt(4); System.out.printf(&quot;%d\t%s\t%f\t%d%n&quot;, id, name, hp, damage);&#125; JDBC初始化驱动导入相关jar包后，使用123456try &#123; Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); System.out.println(&quot;驱动加载成功!&quot;);&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125; 来加载驱动。 链接数据库123Connection c = DriverManager.getConnection( &quot;jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC&quot;, &quot;root&quot;, &quot;password&quot;); 注意：1、127.0.0.1 是数据库所处的ip（本机）。2、3306 数据库端口号。（mysql专用端口号）3、test 数据库名称。4、characterEncoding 编码方式。5、serverTimezone 服务时区，必须要加。 执行SQL语句首先创建Statement对象。12Statement s = c.creatStatement();//Statement使用java.sql.Statement。 再使用s.execute执行sql语句。 123//首先准备SQL语句，再插入String sql = &quot;insert into hero values(null,&quot;+&quot;&apos;提莫&apos;&quot;+&quot;,&quot;+313.0f+&quot;,&quot;+50+&quot;)&quot;;s.execute(sql); 执行SQL语句之前要确保存在相应表。 关闭连接先关闭Statement，再关闭Connection。 123456789101112131415161718finally &#123; if(s != null) &#123; try &#123; s.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; if(c != null) &#123; try &#123; c.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 使用try-with-resource的方式自动关闭连接ry-with-resource的方式自动关闭连接，因为Connection和Statement都实现了AutoCloseable接口。 代码总结12345678910111213141516171819202122232425262728293031public static void main(String[] args) &#123; Connection c = null; Statement s = null; try &#123; Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); c = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/how2java?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC&quot;,&quot;root&quot;,&quot;password&quot;); s = c.createStatement(); String sql = &quot;insert into hero values(null,&quot;+&quot;&apos;提莫&apos;&quot;+&quot;,&quot;+313.0f+&quot;,&quot;+50+&quot;)&quot;; s.execute(sql); &#125; catch (ClassNotFoundException | SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; if(s != null) &#123; try &#123; s.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; if(c != null) &#123; try &#123; c.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 查询账号密码正确1234567String sql = &quot;select * from user where name = &apos;&quot; + &quot;dashen&quot; +&quot;&apos; and password = &apos;&quot; + &quot;123123&quot;+&quot;&apos;&quot;;ResultSet rs = sta.executeQuery(sql);if(rs.next()) &#123; System.out.println(&quot;true&quot;);&#125;else &#123; System.out.println(&quot;false&quot;);&#125; execute和executeUpdate的区别execute与executeUpdate的相同点：都可以执行增加，删除，修改。 不同1：execute可以执行查询语句然后通过getResultSet，把结果集取出来executeUpdate不能执行查询语句不同2:execute返回boolean类型，true表示执行的是查询语句，false表示执行的是insert,delete,update等等executeUpdate返回的是int，表示有多少条数据受到了影响]]></content>
      <categories>
        <category>Java知识体系</category>
      </categories>
      <tags>
        <tag>Java知识体系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet]]></title>
    <url>%2F2019%2F06%2F08%2FServlet%2F</url>
    <content type="text"><![CDATA[创建一个Servlet项目步骤1、创建Java项目。2、导入servlet-api.jar包。3、编写Servlet。4、配置Web.xml。5、将指定的项目输出到classes目录中（兼容tomcat）。6、Tomcat配置与启动。 Servlet生命周期一个Servlet的生命周期由实例化、初始化、提供服务、销毁、被回收几个步骤。 在初始化时Servlet对象被创建进内存，当服务器关闭时Servlet被销毁。 如果在相应的XML文件中配置了 load-on-startup 则生命周期为启动服务器到关闭服务器。 跳转跳转分为服务端跳转和客户端跳转。 服务端跳转1request.getRequestDispatcher(&quot;跳转页面(XXX.html)&quot;).forward(request, response); 服务器跳转中浏览器路径并不会改变。 客户端跳转1response.sendRedirect(&quot;跳转页面&quot;); 客户端跳转浏览器地址改变为跳转页面的路径。 自启动有时候我们需要在Tomcat启动时执行一些初始化代码，但Servlet的生命周期是在用户访问浏览器对应的路径开始的，如果没有用户第一次访问，就无法执行相关代码。这个时候需要Servlet实现自启动，当Tomcat启动时，自动启动初始化，在初始化方法init()中可以进行一些业务代码。 1、在web.xml中需要初始化的Java文件中增加代码1&lt;load-on-startup&gt;10&lt;/load-on-startup&gt; 取值范围为1-99，数字越小，优先级越高表明该Servlet会随着Tomcat的启动而初始化。同时提供一个init(ServletConfig)方法，验证自启动。 request的常见方法一般方法request.getRequestURL(): 浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)”request.getRequestURI(): 浏览器发出请求的资源名部分，去掉了协议和主机名”request.getQueryString(): 请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到request.getRemoteAddr(): 浏览器所处于的客户机的IP地址request.getRemoteHost(): 浏览器所处于的客户机的主机名request.getRemotePort(): 浏览器所处于的客户机使用的网络端口request.getLocalAddr(): 服务器的IP地址request.getLocalName(): 服务器的主机名request.getMethod(): 得到客户机请求方式一般是GET或者POST 获取参数方法request.getParameter(): 是常见的方法，用于获取单值的参数request.getParameterValues(): 用于获取具有多值的参数，比如注册时候提交的 “hobits”，可以是多选的。request.getParameterMap(): 用于遍历所有的参数，并返回Map类型。 获取头信息request.getHeader() 获取浏览器传递过来的头信息。request.getHeaderNames() 获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息 host: 主机地址user-agent: 浏览器基本资料accept: 表示浏览器接受的数据类型accept-language: 表示浏览器接受的语言accept-encoding: 表示浏览器接受的压缩方式，是压缩方式，并非编码connection: 是否保持连接cache-control: 缓存时限 response的用法设置响应内容response.getWriter(); 获取一个PrintWriter 对象可以使用println(),append(),write(),format()等等方法设置返回给浏览器的html内容。 12PrintWriter pw = response.getWriter();pw.println(&quot;···&quot;); 设置响应格式12response.setContentType(&quot;text/html&quot;); //浏览器打开文本response.setContentType(&quot;text/lol&quot;); //浏览器下载 设置响应编码设置响应编码有两种方式：12response.setContentType(&quot;text/html;charset=UTF-8&quot;);response.setCharacterEncoding(&quot;UTF-8&quot;); 这两种方式需要在response.getWriter调用之前执行。 设置不使用缓存123response.setDateHeader(&quot;Expires&quot;,0 );response.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);response.setHeader(&quot;pragma&quot;,&quot;no-cache&quot;); 1234567891011121314151617public class HelloServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; try &#123; response.setDateHeader(&quot;Expires&quot;, 0); response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setHeader(&quot;pragma&quot;, &quot;no-cache&quot;); response.getWriter().println(&quot;&lt;h1&gt;Hello Servlet!&lt;/h1&gt;&quot;); response.getWriter().println(new Date().toLocaleString()); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;]]></content>
      <categories>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>J2EE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat]]></title>
    <url>%2F2019%2F06%2F06%2FTomcat%2F</url>
    <content type="text"><![CDATA[Tomcat安装部署1、在Apache官网下载Tomcat的压缩包。2、解压后在bin目录下运行批处理文件startup.bat，看到Server startup in xxx ms就表明启动成功。3、部署网页，将HTML文件复制到目录webapps\ROOT目录下就可以通过http://127.0.0.1:8080（加HTML文件名）来访问了。 更改Tomcat默认端口http协议的默认端口号为80，因此项目一般在发布的时候需要将Tomcat端口号改为80。 1、首先打开conf\server.xml文件，该文件中包含tomcat的配置信息，包括端口。2、搜索8080，可以找到相关配置信息：123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 将其修改为80，保存，重启tomcat。3、之后就可以省略8080端口访问网页了。（默认接口为80，可省略） Tomcat部署（servlet程序）1、还是打开conf\server.xml文件，找到host。2、添加代码1&lt;Context path=&quot;/&quot; docBase=&quot;E:\\project\\j2ee\\web&quot; debug=&quot;0&quot; reloadable=&quot;false&quot; /&gt; 其中，docBase为项目的目录。3、重启tomcat，并打开项目。]]></content>
      <categories>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>J2EE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[容器和数据结构]]></title>
    <url>%2F2019%2F05%2F22%2F%E5%AE%B9%E5%99%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[泛型基本概念泛型提供了编译时类型安全检测机制。该机制允许程序员在编译时检测到非法类型。泛型的本质时参数化类型，就是说操作的数据类型被指定为一个参数。 自定义泛型我们可以在类的声明出增加泛型列表，如：&lt;T,E,V&gt;。此处，字符可以时任何标识符，一般采用这三个字母。 12345678910111213//泛型类的声明class Mycollection&lt;E&gt;&#123; Object[] objs = new Object[5]; public void set(E e, int index)&#123; objs[index] = e; &#125; public E get(int index)&#123; return (E) objs[index]; &#125;&#125; 泛型E像一个占位符一样表示“未知的某个数据类型”，我们在调用的时候传入这个“数据类型”。 123456789101112//泛型类的使用public class TextGenerics&#123; public static void main(String[] args)&#123; Mucollection&lt;String&gt; mc = new MyCollection&lt;String&gt;(); mc.set(&quot;aaa&quot;, 0); mc.set(&quot;bbb&quot;, 1); String str = mc get(1); System.out.println(str); &#125;&#125; 容器Collection接口Collection表示一组对象。Collection接口的两个子接口是List、Set接口。 Collection接口中定义的方法方法|说明:-:|:-:boolean add(Object element)|增加元素到容器中boolean remove(Object element)|从容器中移除元素boolean contains(Object element)|容器中是否包含该元素int size()|容器中元素的数量boolean isEmpty()|容器是否为空void clear()|清空容器中所有元素Iterator iterator()|获得迭代器，用于遍历容器中所有的元素boolean containsAll(Collection c)|本容器是否包含c容器的所有元素boolean addAll(Collection c)|将c容器的所有元素添加到本容器中boolean removeAll(Collection c)|移除本容器和c容器都包含的元素boolean retainAll(Collection c)|取本容器和c容器中都包含的元素，移除非交集元素Object[] toArray()|转化成Object数组 List特点和常用方法List是有序、可重复的容器。有序：List中每个元素都有索引标记，可以根据元素的索引标记（在List中的位置）访问元素，从而精确控制这些元素。可重复：List允许加入重复的元素。（满足equals方法）。 List接口常用实现类有三个：ArrayList、LinkedList和Vector。 ArrayListArrayList底层是使用数组实现的存储，查询效率高，增删效率低，线程不安全。我们一般使用它。 LinkedList特点和底层实现LinkedList底层用双向链表实现的存储。 特点：查询效率低，增删效率高，线程不安全。 双向链表每个数据节点中都有两个指针，分别指向前一个和后一个节点，所以，从双向链表中的任意一个节点开始，都可以很方便地找到所有节点。 Vector向量Vector底层是用数组实现地List，相关方法加了同步检查，因此线程安全，效率低。 如何选用ArrayList、LinkedList、Vector?1、需要线程安全时，用Vector。2、不存在线程安全问题时，查找较多使用ArrayList。3、不存在线程安全问题时，增加或删除元素较多，用LinkedList。 MAP接口Map是用来存储键值对的，Map类中存储的键值对通过键来标识，所以键对象不能重复。 Map接口的实现类有HashMap、TreeMap、HashTable、Properties等。 Map接口中常用方法：方法|说明:-:|:-:Object put(Object key, Object value)|存放键值对Object get(Object key)|通过键对象查找得到值对象Object remove(Object key)|删除对象对应的键值对boolean containsKey(Object key)|Map容器中是否包含键对象的键值对boolean containsValue(Object value)|Map容器中是否包含值对象的键值对int size()|包含键值对的数量boolean isEmpty()|Map是否为空void putAll(Map t)|将t的所有键值对存在本Map对象void clear()|清空本Map对象所有键值对 HashMap底层原理HashMap底层实现采用了哈希表。 HashMap的底层结构是“数组+链表”。所以哈希表可以结合数组和链表的优点（查询快，增删效率高）。 set接口set接口继承自Collection。set容器特点：无序、不可重复。无序指set中的元素没有索引，只能遍历查找。不能重复指不能加入重复的元素，null元素也只能放一个。 set常用实现类有HashSet和TreeSet，一般使用HashSet。 使用Iterator迭代器遍历容器元素Collections 工具类java.util.Collections提供了对Set、List、Map进行排序的辅助方法。 方法名 作用 void sort(List) 对List容器内的元素惊醒升序排序 void shuffle(List) 对List容器内的元素进行随机排序 void reverse(List) 对List容器内的元素进行逆序排列 void fill(List, Object) 用一个特定的对象重接整个List容器 int binarySearch(List, Object)对于顺序的List容器，采用折半查找法查找数据]]></content>
      <categories>
        <category>Java知识体系</category>
      </categories>
      <tags>
        <tag>Java知识体系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用类]]></title>
    <url>%2F2019%2F05%2F12%2F%E5%B8%B8%E7%94%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[包装类包装类基础在实际应用中我们经常需要将基本数据类型转化为对象，以便于操作。比如：将基本数据类型存储到Object[]数组或集合中的操作。 和基本数据类型对应的类成为包装类。包装类位于java.lang包 基本数据类型 包装类 byte Byte boolean Boolean short Short char Character int Integer long Long float Float double Double 在这八个类中，糊了Boolean和Character类以外，其他的都是数字型，数字型都是java.lang.Number的子类。Number类是抽象类，因此他的抽象方法，所有子类都要实现。 Number类提供了抽象方法intValue()、longValue()、floatValue()、doubleValue()。意味着所有数字型包装类都可以互相转型。 12345public class Test&#123; public static void main(String[] args)&#123; Integer i = new Integer(10); &#125;&#125; 包装类用途包装类一般有两种用途：1、作为和基本数据类型对应的类型存在，方便涉及到对象的操作。2、包含每种基本数据类型的相关属性，如最大值、最小值等，以继相关的方法。 123456789101112131415161718void testInteger()&#123; //基本类型转化为对象 Integer int1 = new Integer(30); Integer int2 = new Integer.valueOf(40); //Integer对象转化为int int a = int1.intValue(); //字符串转化为Integer对象 Integer int3 = Integer.parseInt(&quot;50&quot;); Integer int4 = new Integer(&quot;60&quot;); //Integer对象转化为字符串 String str1 = int3.toString(); //相关常量 System.out.println(&quot;int最大整数：&quot; + Integer.MAX_VALUE);&#125; 自动装箱和拆箱自动装箱基本类型的数据处于需要对象的环境时，会自动转为对象。 123Integer i = 5;//编译器会自动执行以下语句：Integer i = Integer.valueOf(5); //调用valueOf，不是new Integer 自动拆箱自动拆箱通过调用包装类的intValue()方法实现的。 1234Integer i = 5;int j = i; //自动拆箱//编译器会自动执行以下语句：int j = i.intValue(); 包装类空指针异常123//以下语句会显示异常Integer i = null;int j = i; 解决方法：1234Integer i = null;if(i != null)&#123; int j = i;&#125; 包装类的缓存问题整型、char类型所对应的包装类，在自动装箱时，对于-128~127之间的值会进行缓存处理，提高效率。 原理：如果数据在-128~127之间，那么在类加载时，就为该区间每个数值创建了对象，并将这256个对象存储在名为cache的数组中，每当自动装箱过程发生时（或手动调用valueOf时）就会先判断数据是否在该区间，如果在就直接获取数组中对应的包装类对象的引用，如果不在，会通过new调用包装类的构造方法来创建对象。 1234567//Integer类相关源码public static Integer valueOf(int i)&#123; if(i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i+(-IntegerCache.low)]; return new Integer(i);&#125; 注意：IntegerCache类为Integer类的一个静态属性，仅供Integer类使用。 1234567Integer int1 = 30;Integer int2 = 40;System.out.println(&quot;int1 == int2&quot;); //true;Integer int3 = 300;Integer int4 = 400;System.out.println(&quot;int1 == int2&quot;); //false; String类基础特性String类对象代表不可变的Unicode字符序列，因此可以将String对象称为不可变对象（final）。 在字符串常量之间拼接时，编译器会做出优化，在编译期间就会完成字符串的拼接。因此在使用“==”对字符串进行比较时应注意。（字符串比较最好使用equals方法） 12345678String str1 = &quot;hello&quot; + &quot; java&quot;;String str2 = &quot;hello java&quot;; //编译时优化System.out.println(&quot;str1 == str2&quot;); //true;String str3 = &quot;hello&quot;;String str4 = &quot; java&quot;;String str5 = str3 + str4; //编译时不做优化System.out.println(&quot;str2 == str5&quot;); //false; 可变字符序列StringBuffer和StringBuilderStringBuilder和StringBuffer时可变字符序列，StringBuilder线程不安全但效率高；StringBuffer线程安全但效率低。一般使用StringBuilder。 12345678910//StringBuilder使用String str;StringBuilder sb = new StringBuilder(&quot;abcdefg&quot;);System.out.println(Integer.toHexString(sb.hashCode()));System.out.println(sb);sb.setCharAt(2,&apos;M&apos;);System.out.println(Integer.toHexString(sb.hashCode()));System.out.println(sb); //地址不变，字符串改变为abMdefg 常用方法 方法名 作用 重载的public StringBuilder append(···) 为该StringBuilder对象添加字符序列，返回自身对象。 public StringBuilder delet(int start, int end) 删除从start开始到end-1为止的一段字符序列，返回自身对象。 public StringBuilder deleteCharAt(int index) 一处此序列指定位置上的char，返回自身对象。 重载的public StringBuilder insert(···) 为StringBuilder对象在指定位置插入字符序列，返回自身对象。 public StringBuilder reverse() 将字符序列逆序，返回自身对象。 public String toString() 返回序列中数据的字符串表示形式。 和String类含义类似的方法：123456public int indexOf(String str)public int indexOf(String str, int fromIndex)public String substring(int start)public String substring(int start, int end)public int length()char charAt(int index) String类使用陷阱String一经初始化后，就不再改变其内容了，对String字符串的操作实际上是对其副本（原始拷贝的操作，原来的字符串一点都没有改变。 12String s = &quot;a&quot;;s = s + &quot;b&quot;; 如果多次执行这些改变字符串内容的操作，会导致大量副本字符串对象留存在内存中，降低效率，如果放到循环中，会极大的影响程序的时间和空间性能，甚至造成服务器的崩溃。 时间处理相关类基本概念在计算机世界，我们把1970年1月1日00:00:00为基准时间，每个度量单位是毫秒。 我们用long类型的变量来表示时间，如果向获得当前时刻的“时刻数值”，可以使用： 1long now = System.currentTimeMillis(); 这个“时刻数值”是所有时间类的核心值，年月日都是根据这个数值计算出来的。 Date类常用方法 方法 作用 Data() 分配一个Date对象，并初始化子对象为系统当前的日期和时间，可以精确到毫秒。 Data(long data) 分配Data对象并初始化此对象，以表示从标准基准时间依赖的毫秒数。 boolean after(Date when) 测试此日期是否在指定日期之后 boolean before(Date when) 测试此日期是否在指定日期之前 boolean equals(Object obj) 比较两个日期的相等性 long getTime() 返回自标准基准时间以来Date对象表示的毫秒数 String toString() 把此Date对象转换为 dow mon dd hh:mm:ss zzz yyyy的形式（dow是一周中的某一天） DateFormat类和SimpleDataFormat类DateFormat类的作用把时间对象转化成指定格式的字符串。反之，把指定格式的字符串转化为时间对象。 DateFormat是一个抽象类，一般使用他的子类SimpleDateFormat类来实现。 12345678910111213public class TestDateFormat&#123; public static void main(String[] args) throws ParseException&#123; //把时间对象按照格式字符串指定格式转化为相应字符串 SimpleDateFormat dateFormat1 = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); String dateTime = dateFormat1.format(new Date()); System.out.println(dateFormat); //把字符串按照格式字符串格式转化为相应对象 SimpleDateFormat dateFormat2 = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); Date date = dateFormat2.parse(&quot;2019-5-17 11:32:59&quot;); System.out.println(date); &#125;&#125; DateFormat格式化字符串含义 Calendar日历类Calendar类是一个抽象类，为我们提供了关于日期计算的相关功能。 GregorianCalendar是Calendar的一个具体子类，提供了世界上大多数国家/地区的标准日历系统。 注意：月份的表示，一月是0，二月是1，以此类推。 12345678910111213141516//GregorianCalendar类和Calendar类的使用import java.util.*;public class TestCalendar&#123; Calendar calendar = new GregorianCalendar(2019,10,9,22,10,50); //获得日期相关元素 int year = calendar.get(Calendar.YEAR); int month = calendar.get(Calendat.MONTH); System.out.println(year,month); //设置日期的相关元素 calendar.set(Calendar.YEAR, 9102); //日期的计算 calendar.add(Calendar.DATE, 100);&#125; File类File类的基本用法java.io.File类：代表文件和目录。在开发中，读取文件、生成文件、删除文件、修改文件的属性都要使用到本类。 12345678910//文件的创建import java.io.File;public class TestFile&#123; public static void main(String[] args) throws Exception&#123; //本项目目录user.dir System.out.println(System.getProperty(&quot;user.dir&quot;)); File f = new File(&quot;a.txt&quot;); f.creatNewFile(); &#125;&#125;]]></content>
      <categories>
        <category>Java知识体系</category>
      </categories>
      <tags>
        <tag>Java知识体系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言笔记]]></title>
    <url>%2F2019%2F05%2F07%2FC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[二维数组与指针二维数组的定义类型 数组名[常量表达式1][常量表达式2]; 例如：float a[2][3]; 二维数组的引用数组名[行下标][列下标]; 二维数组的初始化1、分行初始化12345int a[3][4] = &#123; &#123;1,2,3,4&#125;, &#123;5,6,7,8&#125;, &#123;9,10,11,12&#125;&#125;; 2、按顺序初始化1int a[3][4] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; 3、部分元素初始化12345int a[3][4] = &#123; &#123; ,1&#125;, &#123;0,6&#125;, &#123;0,0,11&#125;&#125;; 1230 1 0 00 6 0 00 0 11 0 4、如果对全部元素赋值，定义数组可以不指定一维长度1int a[][4] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; 二维数组的输入与输出二维数组的输入与输出是通过对每个元素的输入输出实现的。 1、输入方法123for(int i = 0; i &lt; 2; i++) for(int j = 0; j &lt; 3; j++) scanf(&quot;%d&quot;,&amp;a[i][j]); 2、输出方法123for(int i = 0; i &lt; 2; i++) for(int j = 0; j &lt; 3; j++) printf(&quot;%d&quot;,a[i][j]); 指向二维数组的指针二维数组可以堪称时由多个一维数组的组合。 比如：对于int a[3][4];(1)a是数组名，包含三个元素，a[0],a[1],a[2]。(2)每个元素a[i]又是一个一维数组，包含4个元素。 二维数组的行指针与列指针 例子 类型 意义 a 行指针类型 二维数组的首地址，第0行的地址 a+i 行指针类型 第i行的地址 *(a+i) 列指针类型 第i行第0列的地址 *(a+i)+j 列指针类型 第i行第j列的地址 ((a+i)+j) 元素 第i行第j列的元素 指针与二维数组1、列指针12345678int *p;int a[3][4];p = a[0]; //用列地址初始化int i,j;for(i = 0; i &lt; iMAX; i++) for(j = 0; j &lt; jMAX; j++) printf(&quot;%d&quot;,*(p+i*n+j)); //或p[i*n+j] 2、行指针1234567int (*p)[3]; //行指针，指向数组的一行p = a; //用行指针初始化int i,j;for(i = 0; i &lt; iMAX; i++) for(j = 0; j &lt; jMAX; j++) printf(&quot;%d&quot;,*(*(p+i)+j)); //可以写成p[i][j] 特殊的指针：数组类型指针例如：int (*iPtr)[3]; 类型名：”int”说明其指向的数组变量类型是整型。数组类型指针变量名：”iPtr”说明要定义的变量名字。整型常量表达式：”3”说明指向的数组变量元素个数为3。 指针数组元素均为指针类型数据的数组，称为指针数组定义形式：类型关键字 *数组名[数组长度];例如：char *pStr[5]; 12345678//二维字符数组void main()&#123; int i; char str[][10] = &#123;&quot;Pascal&quot;,&quot;Basic&quot;,&quot;Fortran&quot;,&quot;Java&quot;,&quot;VisualC&quot;&#125;; for(i = 0; i &lt; 5; i++) printf(&quot;%s\n&quot;,str[i]);&#125; 12345678//字符指针数组void main()&#123; int i; char *ptr[] = &#123;&quot;Pascal&quot;,&quot;Basic&quot;,&quot;Fortran&quot;,&quot;Java&quot;,&quot;VisualC&quot;&#125;; for(i = 0; i &lt; 5; i++) printf(&quot;%s\n&quot;,ptr[i]);&#125; 命令行参数int main(int argc, char* argv[]) 动态分配内存1234567891011121314#include&lt;stdlib.h&gt;void* malloc(unsigned int size);//向系统申请大小为size的内存块，返回首地址。申请不成功返回NULL。void* calloc(unsigned int num, unsigned int size);//向系统申请num个size大小的内存块，返回首地址。申请不成功返回NULL。void free(void* p);//释放由malloc和calloc申请的内存块。p是指针。//例如：if(p == NULL)&#123;free(p); p = NULL&#125;void* realloc(void* pointer, unsigned int size);//如果重新分配成功，返回指向被分配内存的指针，否则返回空指针NULL。 结构体结构体的定义一般形式：12345struct 结构体名&#123; 类型关键字 成员名1; 类型关键字 成员名2; 类型关键字 成员名3;&#125;; 例如：12345struct student&#123; int ID; char name[20]; int age;&#125;; 结构体只是定义了数据的形式，未生成任何变量，可以如下定义：struct student stu;。 定义类型名12345typedef struct student&#123; int ID; char name[20]; int age;&#125;STUD; 或直接typedef struct student STUD;。 定义的类型名就与普通数据形式一样的使用方法。 链表类型：12345struct student&#123; int ID; struct student* next;&#125;;typedef struct student Node; 尾插法创建链表基本思路：1、申请一个节点的空间，置指针域为空。2、输入结点数据域的数据。3、搜索链表的最后一个结点。4、将新结点插入到链表尾。5、返回头指针。 12345678910111213141516171819202122232425Node* Add_end(Node* head)&#123; Node *p; Node *tail; p = (Node*)malloc(sizeof(Node)); if(NULL == p)&#123; printf(&quot;Wrong!&quot;); exit(1); &#125; p-&gt;next = NULL; scanf(&quot;%d&quot;,&amp;(p-&gt;ID) ); //一个结点创建完毕。 if(NULL == head)&#123; head = p; &#125; else&#123; tail = head; while(tail-&gt;next != NULL)&#123; tail = tail-&gt;next; &#125; //找到尾节点 tail-&gt;next = p; //插入 &#125; return head; //返回&#125; 头插法创建链表基本思路：1、建立空链表，但不需要定义尾指针。2、生成新结点，对新结点赋值，指针域可不必赋值。3、将结点插入到链表中。 12345678910111213141516Node* Add_head(Node* head)&#123; Node* p; p = (Node*)malloc(sizeof(Node)); if(NULL == p)&#123; printf(&quot;Wrong!&quot;); exit(1); &#125; p-&gt;next = NULL; scanf(&quot;%d&quot;,&amp;(p-&gt;ID)); //单个结点创建完成 p-&gt;next = head; head = p; //插入完成 return head;&#125; 文件操作打开文件fopen常用的打开文件方法：1234if( (fp = fopen(&quot;文件名&quot;,&quot;操作方式&quot;)) == NULL )&#123; printf(&quot;打不开文件\n&quot;); exit(1);&#125; 文件操作方式： 文件操作方式 含义 r(只读) 为输入打开一个文本文件 w(只写) 为输出打开一个文本文件 a(追加) 向文本文件尾增加数据 rb(只读) 为输入打开一个二进制文件 wb(只写) 为输出打开一个二进制文件 ab(追加) 向二进制文件尾增加数据 r+(读写) 为读/写打开一个文本文件 w+(读写) 为读/写建立一个新的文本文件 a+(读写) 为读/写打开一个文本文件 rb+(读写) 为读/写打开一个二进制文件 wb+(读写) 为读/写建立一个新的二进制文件 ab+(读写) 为读/写打开一个二进制文件 规律：1、含有”b”的为二进制文件操作。2、含有”+”的可以进行读写操作，且可以新建文件。 文件关闭fclose函数原型：int fclose(FILE *fp); 功能：关闭fp所指向的文件。 正常关闭返回0，出错返回非0值。 读/写文件中的一个字符写入一个字符到文件中——fputc函数原型：int fputc(int c, FILE *fp); 功能：把一字节代码c写入fp指向的文件中，同时读写位置指针指向下一个写入位置。 返回值：正常，返回c（ASCLL码）；错误返回EOF。 从文件中读取一个字符——fgetc函数原型：int fgetc(FILE *fp) 功能：从fp指向的文件中读取一字节代码。 返回值：正常，返回读到的代码值；读到文件为或出错，返回EOF。 库函数feof函数原型：int feof(FILE *fp) 功能：执行读文件操作时，遇到文件尾，返回逻辑真；否则返回0。 读/写一个字符串读一个字符串——fgets函数原型：char *fgets(char *s, int n, FILE *fp) 功能：从fp所指向文件读n-1个字符送股s指向的内存区，并在最后加一个’\0’。 返回值：正常时返回读取字符串的首地址；出错或遇文件尾返回NULL。 写一个字符串——fputs函数原型：int fputs(char *s, FILE *fp) 功能：把s指向的字符串写入fp指向的文件。 返回值：正常时返回写入的最后一个字符；出错为EOF。 读/写一个数据块读一个数据块——fread函数原型：int fread(void *buffer, int size, int count, FILE *fp) 功能：从fp所指向的文件的当前位置开始，一次读入size个字节，重复count次，并将读入的数据存放到从buffer开始的内存中；同时，将读写位置指针移动size*count个字节。 返回值：调用成功，返回count；否则为0。 注意：一般用于二进制文件的处理。 写一个数据块——fwrite函数原型：int fwrite(void buffer, int size, int count, FILE *fp) 功能：从buffer开始，一次输出size个字节，重复count次，并将输出的数据存放到fp所指向的文件中；同时将读写文件位置指针移动size*count个字节。 返回值：调用成功，返回count；否则为0。 注意：一般用于二进制文件的处理。 对文件进行格式化读写函数原型：1、读入：int fscanf(FILE *fp,const char*format,[argument,···])2、写出：int fprintf(FILE *fp,const char*format,[argument,···]) 功能：按格式对文件进行I/O操作。 返回值：成功，返回I/O的个数；出错或文件尾，返回EOF。 位置指针和文件定位位置指针复位函数——rewind函数原型：void rewind(FILE *fp) 功能：使文件的位置指针返回到文件头。 移动文件位置指针函数fseek函数原型：int fseek(FILE *fp, long int offset, int whence) 功能：将指定文件的位置指针，从参照点开始，移动指定的字节数。 参照点：’0’或SEEK_SET表示文件头，’1’或SEEK_CUR表示当前位置，’2’或SEEK_END表示文件尾。 返回值：成功为0；否则为非0值。 注意：一般用于二进制文件处理。 返回文件当前位置的函数ftell函数原型：long int ftell(FILE *fp) 功能：返回文件位置指针的当前位置（用相对于文件头的位移量表示）。如果返回值为-1L表明调用出错。 123offset = ftell(fp);if(offset == -1L) printf(&quot;ftell() error\n&quot;); 出错检测ferror函数函数原型：int ferror(FILE *fp) 功能：如果返回值为0，表示未出错；返回非0值，表示出错。 注意：(1)对同一文件，每次调用输入输出函数均产生新的ferror()函数值。因此调用的输入输出函数后，应立即检测，否则出错信息会丢失。(2)在执行fopen函数时，系统将ferror的值设为0。 clearerr函数函数原型：void clearerr(FILE *fp) 功能：将文件错误标志（ferror的值）和文件结束标志（feof的值）置为0。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS基础]]></title>
    <url>%2F2019%2F04%2F30%2FCSS%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[CSS样式规则CSS的一般样式：选择器 {属性:值; 属性:值;}。 1、选择器用于指定CSS样式作用的HTML对象，花括号内是对该对象设置的具体样式。2、属性和属性值以“键值对”的形式出现。3、属性是对指定的对象设定的样式属性，例如字体大小、文本颜色等。4、属性和属性值之间用英文”:”连接。5、多个“键值对”之间用英文”;”进行区分。 123456789&lt;head&gt; &lt;meta charset = &quot;UTF-8&quot; /&gt; &lt;style&gt; h1 &#123; color: red; font-size: 40px; &#125; &lt;/style&gt;&lt;/head&gt; 字体样式属性font-size字号大小font-size属性用于设置字号，该属性的值可以用相对长度单位，也可以使用绝对长度单位。其中，相对长度单位比较常用。推荐使用像素单位px。 相对长度单位 说明 em 相对于当前对象内文本的字体尺寸 px 像素，最常用 绝对长度单位 说明 in 英寸 cm 厘米 mm 毫米 pt 点 font-family字体font-family属性用来设置字体，网页中常用的字体有：宋体、微软雅黑、黑体等，例如p {font-family: &quot;微软雅黑&quot;,&quot;宋体&quot;;}。 可以同时指定多个字体，中间以逗号隔开表示浏览器如果不支持第一个字体，会找下一个直到兼容为止。 常用技巧：1、现在网页中普遍使用14px+。2、尽量使用偶数数字字号，老式浏览器会有BUG。3、各种字体之间必须用英文逗号隔开。4、中文字体需要加英文状态下的引导，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。5、如果字体名中包含空格、#、$等符号，该字体必须加英文状态下的单引号或双引号。例如：font-family: &quot;Times New Roman&quot;;。6、尽量使用系统默认字体，保证任何用户在浏览器中动能正确显示。 CSS Unicode字体在CSS中设置字体名称，直接写中文是可以的，但是在文件编码时可能会不匹配而产生乱码错误。 方案一：使用英文来替代。font-family: &quot;Microsoft Yahei&quot;;。 方案二：在CSS中直接使用Unicode编码来写字体名称可以避免这些错误。 注意：尽量只写Unicode字体，写宋体(\5B8B\4F53)和微软雅黑(\5FAE\8F6F\96C5\9ED1)。 font-weight设置字体粗细字体加粗除了使用&lt;b&gt;&lt;/b&gt;或&lt;strong&gt;&lt;/strong&gt;标签外，可以使用CSS来实现，但是CSS时没有语义的。 font-weight属性用于定义字体的粗细，其可用属性值normal、bold、bolder、lighter、100~900（100的整数倍）。 注意：数字400为normal，700为bold。我们一般使用数字表示。 font-style字体风格字体倾斜除了用&lt;i&gt;&lt;/i&gt;和&lt;em&gt;&lt;/em&gt;标签外，可以使用CSS来实现，但CSS是没有语义的。 font-style属性用于定义字体风格。其可用属性如下：1、normal，浏览器显示标准字体样式。2、italic，浏览器显示斜体字体样式。3、oblique，浏览器显示倾斜的字体样式。 注意：平时我们很少给文字加斜体，一般用将斜体标签改为普通模式。 font综合设置字体样式（重点）font属性用于对字体样式进行综合设置，基本语法格式： 1选择器 &#123;font: font-style font-weight font-size/line-height font-family;&#125; 注意：1、使用font属性，必须按照上面语法格式的顺序书写，并以空格隔开。2、其中不需要设置的属性可以忽略（或取默认值），但必须保留font-size和font-family属性（最后两个属性），否则font属性不起作用。 选择器标签选择器标签选择器是指用HTML标签名称作为选择器，按标签名称分类，为页面的某一类标签统一设置CSS样式。 1标签名 &#123;属性1：属性值1； 属性2：属性值2； ···&#125; 标签选择器最大的优点事能快速为页面中同类型的标签统一样式，同时也是缺点，不能差异化设置样式。 类选择器类选择器使用“.”进行标识，后面紧跟类名。 1.类名&#123;属性1：属性值1； 属性2：属性值2； ···&#125; 标签调用的时候用class = &quot;类名&quot;即可。 类选择器最大优势是可以为元素对象定义单独或相同的样式。 注意：1、长名称或字组可以使用中横线来为选择器命名。2、不建议使用“_”下划线来命名CSS选择器。3、不要用纯数字、中文等命名，尽量使用英文字母来表示。 多类名选择器1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;meta charset = &quot;UTF-8&quot; /&gt; &lt;title&gt;多类名选择器&lt;/title&gt; &lt;style&gt; .font20 &#123; font-size: 20px; &#125; .pink &#123; color: pink; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class = &quot;font20 pink&quot;&gt;20px 粉色&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 注意：样式显示效果跟HTML元素中的类名先后顺序没有关系，而与CSS样式书写的上下顺序有关。 id选择器id选择器使用#进行标识，后面紧跟id名，基本语法： 1#id名&#123;属性1：属性值1； 属性2：属性值2； 属性3：属性值3；&#125; 注意：1、id名为HTML元素id的属性值。2、元素的id是唯一的，只能对应文档的某一个具体元素。3、在同一个页面，不允许有相同名字的id对象出现，但允许相同名字的class。 通配符选择器通配符选择器用*表示，他是所有选择器中作用范围最广的，能匹配页面中所有元素，语法格式：1* &#123;属性1：属性值1； 属性2：属性值2； 属性3：属性值3；&#125; 12345/*使用通配符选择器清除默认边距*/* &#123; margin: 0; /*定义外边距*/ padding: 0; /*定义内边距*/&#125; 注意：因为通配符选择器范围广，很少使用。 伪类选择器伪类选择器用于向某些选择器添加特殊效果。比如给连接添加特殊特殊效果。 一般语法：:link{}。 链接伪类选择器1234:link /*未访问的链接*/:visited /*已访问的连接*/:hover /*鼠标移动到链接上*/:active /*选定的链接(鼠标点击不松开)*/ 1234567891011121314151617181920212223242526272829303132&lt;html&gt;&lt;head&gt; &lt;meta charset = &quot;UTF-8&quot;/&gt; &lt;style&gt; a:link&#123; font-size: 16px; color: gray; font-weight: 700; &#125; a:visited&#123; font-size: 16px; color: orange; font-weight: 700; &#125; a:hover&#123; font-size: 16px; color: red; font-weight: 700; &#125; a:active&#123; font-size: 16px; color:green; font-weight: 700; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;a&gt;点击链接&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 注意：写的时候，顺序尽量不要颠倒。 实际工作中，简单写链接伪类选择器就行了 12345678a&#123; font-weight: 700; font-size: 16px; color: gray;&#125;a:hover&#123; color: red;&#125; 结构（位置）伪类选择器(CSS3)1234:first-child: /*选取其父元素首个子元素的指定选择器。*/:last-child: /*选取其父元素最后一个子元素的指定选择器。*/:nth-child(n): /*匹配数以其父元素的第N个子元素，n从0开始*/:nth-last-child(n): /*从最后一个孩子开始数*/ 1234567891011121314151617181920212223242526&lt;html&gt;&lt;head&gt; &lt;style&gt; li:first-child&#123; color: red; &#125; li:last-child&#123; color: purple; &#125; li:nth-child(4)&#123; color:skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;第一个孩子&lt;/li&gt; &lt;li&gt;第二个孩子&lt;/li&gt; &lt;li&gt;第三个孩子&lt;/li&gt; &lt;li&gt;第四个孩子&lt;/li&gt; &lt;li&gt;第五个孩子&lt;/li&gt; &lt;li&gt;第六个孩子&lt;/li&gt; &lt;li&gt;第七个孩子&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223&lt;html&gt;&lt;head&gt; &lt;style&gt; li:nth-child(odd)&#123; //选取奇数孩子也可以用2n+1 color:skyblue; &#125; li:nth-child(even)&#123; //选取偶数孩子也可以用2n color:pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;第一个孩子&lt;/li&gt; &lt;li&gt;第二个孩子&lt;/li&gt; &lt;li&gt;第三个孩子&lt;/li&gt; &lt;li&gt;第四个孩子&lt;/li&gt; &lt;li&gt;第五个孩子&lt;/li&gt; &lt;li&gt;第六个孩子&lt;/li&gt; &lt;li&gt;第七个孩子&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 目标伪类选择器:target目标伪类选择器，选择器可用于选取当前活动的目标元素。 123:target&#123; color: red;&#125; CSS外观属性color文本颜色color属性用于定义文本的颜色，其取值方式有如下三种：1、预定义的颜色值，如red，green，blue等。2、十六进制，如#FF0000,#FF6600,等。实际中，十六进制最常用。3、RGB代码，如红色可以表示为rgb(255,0,0)或rgb(100%,0%,0%)。 line-height行间距line-height用于设置行间距。常用属性值有三种，分别为像素px（常用），相对值em和百分比%。一般情况下，行距比字号大7.8像素左右就可以了。 123p&#123; line-height: 30px;&#125; text-align水平对齐方式text-align属性用于设置文本内容的水平对齐，相当于html中的align对齐属性，其可用属性值如下：1、left：左对其（默认值）2、right：右对齐3、center：居中对齐 text-indent首行缩进text-indent属性用于设置首行文本的缩进，其属性值可为不同单位的数值、em（建议使用）字符宽度的倍数，或相对于浏览器窗口宽度的百分比%。 1em是一个字的宽度，如果是汉字，就是一个汉字的宽度。 123p&#123; text-indent: 2em;&#125; letter-spacing字间距letter-spacing属性用于定义字间距，其属性值可为不同单位的数值，默认为normal。 123div&#123; letter-spacing: 2px;&#125; word-spacing单词间距word-spacing属性用于定义英文单词之间的间距，对中文字符无效。默认为normal。 word-spacing和letter-spacing均可以设置英文，letter-spacing设置字母之间的间距。 颜色半透明（CSS3）123h1&#123; color: rgba(0, 0, 0, 0.5);&#125; a是alpha，取值范围0~1之间。 文字阴影（CSS3）语法格式： 1text-shadow: 水平位置 垂直位置 模糊距离(模糊程度) 阴影颜色; 123h1&#123; text-shadow: 5px 5px 3px rgba(0, 0, 0, 0.3);&#125; 注意：前两项必须写，后两项可以省略。 引入CSS样式表内部样式表一般语法：12345&lt;head&gt; &lt;style&gt; 选择器&#123;属性1：属性值1;···&#125; &lt;/style&gt;&lt;/head&gt; 行内式（内联样式）1&lt;标签名 style = &quot;属性值1; 属性值2; ···&quot;&gt;内容&lt;/标签名&gt; 1&lt;div style = &quot;color = pink;&quot;&gt;粉红色&lt;/div&gt; 外部样式表123&lt;head&gt; &lt;link href = &quot;CSS文件的路径&quot; type = &quot;text/CSS&quot; rel = &quot;stylesheet&quot; /&gt;&lt;/head&gt; 注意：1、href：定义所连接外部样式表的URL，可以是相对路径或绝对路径。2、type：定义所链接文档的类型，需要指定为“text/CSS”，表示链接的文件是CSS样式表。3、rel：定义当前文档与被链接文档之间的关系，这里需要指定为“stylesheet”表示被链接文档是一个样式表文件。 标签显示模式HTML标签一般分为块标签和行内标签两种类型。 块级元素-block每个块级元素通常会肚子占据一整行或多整行，可以对其设置高度、宽度、对齐等属性，常用于网页布局和王爷结构的搭建。 div标签是最典型的块级元素。 块级元素的特点：1、总是从新行开始。2、高度、行高、外边距以及内边距都可以控制。3、宽度默认是容器的100%。4、可以容纳内联元素和其他块元素。 行内元素-inline行内元素不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度。常用于控制页面中文本的样式。 常见行内元素：a、strong、b、em、i、del、s、ins、u、span等，span是最典型的行内元素。 行内元素特点：1、和相邻元素在一行上。2、高、宽无效，但水平方向的padding和margin可以设置，垂直方向无效。3、默认宽度是它本身内容的宽度。4、行内元素只能容纳文本或其他行内元素。 行内块元素-inline-block在行内元素中有几个特殊的标签：img、input、td可以对它们设置宽高和对齐属性。 行内块元素的特点：1、和相邻元素在一行上，但之间会有空白间隙。2、默认宽度为本身内容宽度。3、高度，行高，外边距和内边距可控。 标签显示模式转换 display块转行内：display:inline;行内转块：display:block;块、行内元素转换为行内块：display:inline-block; CSS复合选择器交集选择器1234567891011121314&lt;head&gt; &lt;style&gt; .red &#123; color: red; &#125; div.red &#123; //交集选择器 font-size: 15px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class = &quot;red&quot;&gt;字体不会变化&lt;/p&gt; &lt;div class = &quot;red&quot;&gt;字体会变化&lt;/div&gt;&lt;/body&gt; 并集选择器并集选择器通过逗号连接而成，任何形式选择器都可以作为并集选择器的一部分。 1234567&lt;style&gt; div, .name, #test &#123; font-size: 15px; &#125;&lt;/style&gt; 后代选择器将外层标签写在前面，内层标签卸载后面，中间用空格分隔。 123456789101112131415161718&lt;head&gt; &lt;style&gt; div p&#123; color: red; &#125; .class p&#123; color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;这是红色&lt;/p&gt; &lt;/div&gt; &lt;div class = &quot;class&quot;&gt; &lt;p&gt;这是蓝色&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 子元素选择器12345678910111213141516171819202122232425262728&lt;head&gt; &lt;style&gt; .nav &gt; li &#123; //只有一级菜单为粉色 color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class = &quot;nav&quot;&gt; &lt;li&gt;一级菜单 &lt;ul&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 属性选择器只存在属性类型12345678&lt;style&gt; a[title]&#123; color: red; &#125;&lt;/style&gt;&lt;a href = &quot;#&quot; title = &quot;百度&quot;&gt;百度&lt;/a&gt;&lt;a href = &quot;#&quot;&gt;新浪&lt;/a&gt; 属性和值类型12345678&lt;style&gt; input[type = text]&#123; color = red; &#125;&lt;/style&gt;&lt;input type = &quot;text&quot; value = &quot;文本框&quot; /&gt;&lt;input type = &quot;submit&quot; /&gt; 通配类型12345678910111213141516171819&lt;style&gt; div[class^=font]&#123; //font在类名前 color: red; &#125; div[class&amp;=footer]&#123; //footer在类名后 color: blue; &#125; div[class*=news]&#123; //包含news的所有类 color: yellow; &#125;&lt;/style&gt;&lt;div class = &quot;font1&quot;&gt;属性选择器&lt;/div&gt;&lt;div class = &quot;font2&quot;&gt;属性选择器&lt;/div&gt;&lt;div class = &quot;font3&quot;&gt;属性选择器&lt;/div&gt;&lt;div class = &quot;sub-footer&quot;&gt;属性选择器&lt;/div&gt;&lt;div class = &quot;the-news-paper&quot;&gt;属性选择器&lt;/div&gt; 伪元素选择器123456789101112&lt;style&gt; p::first-letter&#123; //段落中第一个字 color: red; font-size: 50px; &#125; p::first-line&#123; //段落中第一行 color: green; &#125; p::selection&#123; //被选中的部分 color:pink; &#125;&lt;/style&gt; 1234567891011121314&lt;head&gt; &lt;style&gt; div::before&#123; content: &quot;我&quot;; &#125; div::after&#123; content: &quot;18岁&quot;; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;今年&lt;div&gt;&lt;/body&gt; CSS背景（background）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础]]></title>
    <url>%2F2019%2F04%2F30%2FHTML%2F</url>
    <content type="text"><![CDATA[HTML初识HTML骨架格式1234567&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;html&gt; 标签解读：1、html标签：作用所有html中标签的一个根节点。2、head标签：用于存放：title（必须设置）、meta、base、style、script、link标签。3、title标签：页面的标题。4、body标签：页面主体部分，用于存放所有的标签。 HTML标签分类双标签1&lt;标签名&gt;内容&lt;/标签名&gt; 左边为开始标签，右边为结束标签，相对于开始标签多一个“/”结束符。 单标签&lt;标签名/&gt; 单标签也称空标签，一个标签即可完成相应功能。 1&lt;br /&gt; //换行标签 HTML标签关系嵌套关系123&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt; 并列关系12&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; sublime快速生成骨架1、html:52、!然后按下tab键即可生成HTML骨架。 文档类型&lt;!DOCTYPE&gt;1&lt;!DOCTYPE html&gt; 告诉我们使用哪个HTML版本。 这是HTML5的版本。 字符集简介（meta）1&lt;meta charset = &quot;UTF-8&quot;&gt; UTF-8是目前最常用的字符集编码方式，常用的字符集编码方式还有GBK和GB2312。 以后统统使用UTF-8的字符集。 HTML常用标签排版标签标题标签（熟记）单词缩写：head 为了使网页具有语义化，经常会在页面中用到标题标签，HTML提供了6个等级的标题 123&lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;和&lt;h6&gt;&lt;h1&gt;这是最大的标题&lt;/h1&gt; 注意：h1标签因为重要，尽量少用。一般都是给logo使用。 段落标签（熟记）单词缩写：paragraph 在网页中要把文字有条理地显示出来，离不开段落标签。 1&lt;p&gt;段落内容&lt;/p&gt; 默认情况下，文本在一个段落中会根据浏览器窗口地大小自动换行。 水平线标签（认识）单词缩写：horizontal 横线 在网页中常常看到一些水平线将段落与段落分开，使文档结构清晰，层次分明。 1&lt;hr /&gt; 单标签 在网页中显示默认样式水平线。 换行标签（熟记）单词缩写：break 打断，换行 在HTML中，一个段落中地文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，需要使用换行标签。 1&lt;br /&gt; 单标签 div和span标签（重点）单词缩写：division 分割，分区 span 跨度，范围 div和span是没有语义的，是我们网页布局主要的两个盒子。 文本格式化标签（熟记）在网页中，有时要为文字设置粗体、斜体或下划线效果，这是需要用到HTML中的文本格式化标签，使文字以特殊格式展现。 标签 显示效果 &lt;b&gt;&lt;/b&gt; &lt;strong&gt;&lt;/strong&gt; 文字以粗体的方式显示 &lt;i&gt;&lt;/i&gt;&lt;em&gt;&lt;/em&gt; 文字以斜体方式显示 &lt;s&gt;&lt;/s&gt;&lt;del&gt;&lt;/del&gt; 文字以加删除线方式显示 &lt;u&gt;&lt;/u&gt;&lt;ins&gt;&lt;/ins&gt; 文字以加下划线方式显示 strong、em、del、ins有强调语义的意思，推荐使用这四个标签。 1234567891011&lt;b&gt;我是粗体&lt;/b&gt; &lt;br /&gt;&lt;strong&gt;我是粗体，并强调语义&lt;/strong&gt; &lt;br /&gt;&lt;i&gt;我是斜体&lt;/i&gt; &lt;br /&gt;&lt;em&gt;我是斜体，并强调语义&lt;/em&gt; &lt;br /&gt;&lt;s&gt;我加删除线&lt;/s&gt; &lt;br /&gt;&lt;del&gt;我加删除线，并强调语义&lt;/del&gt; &lt;br /&gt;&lt;u&gt;我加下划线&lt;/u&gt; &lt;br /&gt;&lt;ins&gt;我加下划线，并强调语义&lt;/ins&gt; &lt;br /&gt; 标签属性使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置，其基本语法格式如下：1&lt;标签名 属性1 = &quot;属性值1&quot; 属性2 = &quot;属性值2&quot;&gt;文本内容&lt;/标签名&gt; 12要求：水平线的长度为500,颜色为红色。&lt;hr width = &quot;500&quot; color = &quot;red&quot; /&gt; 语法规则：1、标签可以有多个属性，必须写在开始标签之中，位于标签名之后。2、属性之间部分先后顺序，标签名与属性、属性与属性之间均已空格分开。3、任何标签的属性都有默认值省略该属性则取默认值。 图像标签img（重点）单词缩写：image 图像 1&lt;img src = &quot;图像URL&quot; /&gt; 单标签 该语法中src属性用于指定图像文件的路径和文件名，它是img标签的必须属性。 标记属性 属性 属性值 描述 src URL 图像的路径 alt 文本 图像不能显示时的替换文本 title 文本 鼠标悬停时显示的内容 width 像素（不支持%页面百分比） 设置图像的宽度 height 像素（不支持%页面百分比） 设置图像高度 border 数字 设置图像边框的宽度 1&lt;img src = &quot;#&quot; alt = &quot;替换文本&quot; title = &quot;悬停文本&quot; width = &quot;200&quot; border = &quot;10&quot; /&gt; 链接标签（重点）基本使用单词缩写：anchor 锚 在HTML中创建超链接非常简单，只需用标签环绕需要被链接的对象即可。 1&lt;a href = &quot;跳转目标&quot; target = &quot;目标窗口弹出方式&quot;&gt;文本或图像&lt;/a&gt; href：用于指定链接目标的URL地址。target：用于指定链接页面的打开方式，其取值（目前）有_self和_blank两种，_self为默认值，_blank为在新窗口中打开。（下划线不能省略） 注意：1、外部链接需要添加”http://“1&lt;a href = &quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; 2、内部链接直接链接内部页面名称即可。1&lt;a href = &quot;index.html&quot;&gt;首页&lt;/a&gt; 3、没有确定链接目标时，通常将href属性设为”#”。1&lt;a href = &quot;#&quot;&gt;不确定的网页&lt;/a&gt; 4、不仅可以创建文本链接，在网页中各种网页元素，如图像、表格、音频和视频等都可以添加超链接。 锚点链接（难点）通过创建锚点定位，用户可以快速定位到目标内容。如该博客的目录，点击相应内容，即可跳转至该位置。 创建锚点定位分两步：1、使用&lt;a href = &quot;#id&quot;&gt;链接文本&lt;/a&gt;创建链接文本。2、使用相应的id名标注跳转目标位置。 12&lt;a href = &quot;#live&quot;&gt;个人生活&lt;/a&gt;&lt;h3 id = &quot;live&quot;&gt;个人生活&lt;/h3&gt; base标签base可以设置整体链接的打开状态。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;base标签&lt;/title&gt; &lt;meta charset = &quot;UTF-8&quot; /&gt; &lt;base target = &quot;_blank&quot; /&gt; //页面中所有链接以新窗口打开 &lt;/head&gt; &lt;body&gt; &lt;a href = &quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;a href = &quot;http://www.sina.com&quot; target = &quot;_self&quot;&gt;新浪&lt;/a&gt; //当前窗口打开 &lt;a href = &quot;http://www.sohu.com&quot;&gt;搜狐&lt;/a&gt; &lt;a href = &quot;http://www.163.com&quot;&gt;网易&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 特殊字符标签（理解）有些特殊的符号无法直接显示在页面上，HTML为其编配了特殊字符编码。 注释标签如果需要在HTML文档里添加一些便于阅读和理解但又不需要显示在页面中的文字，就需要使用注释标签。 1&lt;!-- 注释语句 --&gt; 快捷键：ctrl+/ 注释内容不会显示在浏览器窗口中，但是作为HTML文档内容的一部分，会被下载到用户的计算机上，查看源码时就会看到。 路径（重点、难点）实际工作中，通常新建文件夹专门用来存放图像文件，这是插入图像文件就需要采用“路径”的方式来指定图像文件。 相对路径1、图像文件和HTML文件位于同一文件夹：只需要输入图像文件的名称即可。1&lt;img src = &quot;logo.gif&quot; /&gt; 2、图像文件位于HTML文件的下一级文件夹：输入文件夹名和文件名，之间用”/“隔开。1&lt;img src = &quot;img/logo.gif&quot; /&gt; 3、图像位于HTML文件的上一级文件夹：在文件名之前加入”../“,如果时上两级，则使用”../../“。1&lt;img src = &quot;../logo.gif&quot; /&gt; 绝对路径绝对路径D:\web\img\logo.gif 或完整的网络地址http://www.baidu.com/img/logo.gif。 列表标签无序列表（重点）无序列表的各列表之间没有顺序级别之分，是并列的。其基本语法格式如下： 123456&lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ···&lt;/ul&gt; 注意事项：1、&lt;ul&gt;标签内除了&lt;li&gt;标签最好不要放其他标签。2、&lt;li&gt;标签相当于一个容器，里面可以包含其他标签，如&lt;p&gt;、&lt;h1&gt;等。3、无序列表有自己的属性，但通常由CSS来完成样式的调配。 有序列表（了解）12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;ol标签的使用&lt;/title&gt; &lt;meta charset = &quot;UTF-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;高考排行榜&lt;/h2&gt; &lt;ol&gt; &lt;li&gt;小明 分数：750&lt;/li&gt; &lt;li&gt;小红 分数：670&lt;/li&gt; &lt;li&gt;小黄 分数：490&lt;/li&gt; &lt;li&gt;小雨 分数：233&lt;/li&gt; &lt;/ol&gt; &lt;body&gt;&lt;/html&gt; 自定义列表（理解）自定义列表通常对术语或名词进行解释或描述，自定义列表的列表项前没有任何项目符号。 12345678910&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; ··· &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; ···&lt;/dl&gt; 应用的场景： 表格和表单表格table（会使用）表格现在还是一种较为常用的标签，但不是用来布局，常见处理和显示表格式数据。 创建表格创建表格的基本语法： 123456789&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ··· &lt;/tr&gt; &lt;tr&gt; ··· &lt;/tr&gt;&lt;/table&gt; 1、table用于定义一个表格。2、tr用于定义表格中的一行，必须嵌套在tabel标签内，在tabel标签中有几对tr标签就有几行表格。3、td用于定义表格中的单元格，必须嵌套在tr标签内。4、td标签像一个容器，里边可以放其他标签。如：p、div、span等。 表格属性 属性名 含义 常用属性值 border 设置表格的边框（默认为0，无边框） 像素值 cellspacing 设置单元格与单元格边框之间的空白间距 像素值（默认为2） cellpadding 设置单元格内容与单元格边框之间的空白间距 像素值（默认为1） width 设置表格宽度 像素值 height 设置表格高度 像素值 align 设置表格在网页中的水平对齐方式 left、center、right 表头标签表头一般位于表格的第一行或第一列，一般要用特殊的格式突出显示表头。设置表头标签用&lt;th&gt;&lt;/th&gt;替代相应单元格标签&lt;td&gt;&lt;/td&gt;即可。 表格结构在使用表格进行布局时，可以将表格分为头部、主体。&lt;thead&gt;&lt;/thead&gt;用于定义表格的头部。&lt;tbody&gt;&lt;/tbody&gt;用于定义表格的主体。 表格标题caption元素定义表格的标题。 123&lt;table&gt; &lt;caption&gt;我是表格的标题&lt;/caption&gt;&lt;/table&gt; caption标签必须紧随table标签之后。只能对每个表格定义一个标签。标题会被居中于表格之上。 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;table使用&lt;/title&gt; &lt;meta charset = &quot;UTF-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;table&gt; &lt;caption&gt; 火影忍者演员表 &lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;!-- 表格样式留给CSS做 --&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;鸣人&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;佐助&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;19&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 合并单元格（难点）跨行合并：rowspan跨列合并：colspan 12345678910111213141516171819202122&lt;table&gt; &lt;caption&gt; 合并单元格 &lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;第一列&lt;/th&gt; &lt;th&gt;第二列&lt;/th&gt; &lt;th&gt;第三列&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td rowspan = &quot;2&quot;&gt;跨行合并&lt;/td&gt; &lt;td&gt;未合并&lt;/td&gt; &lt;td&gt;未合并&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan = &quot;2&quot;&gt;跨列合并&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 表单标签（掌握）我们在网页中，有时要与用户进行交互，收集用户信息，此时需要使用表单。 在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域三个部分构成。 表单控件：包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮等。提示信息：提示用户输入信息的提示性文字。表单域：相当于一个容器，用来容纳所有表单控件和提示信息。可以通过它来定义处理表单数据所用程序的URL地址，以及数据提交到服务器的方式。如果不定义表单域，表单中的数据无法传输到服务器。 input控件（重点）input标签为单标签，type实行为其最基本属性，其取值有多种，用于指定不同的控件类型。 123456789101112131415161718192021222324用户名：&lt;input type = &quot;text&quot; value = &quot;请输入用户名······&quot;/&gt; &lt;br /&gt;&lt;!-- 文本框 框内预先有value文本 --&gt;密 码：&lt;input type = &quot;password&quot; maxlength = &quot;6&quot; /&gt; &lt;br /&gt;&lt;!-- 密码框 最多输入六个字符 --&gt;性 别：&lt;input type = &quot;radio&quot; name = &quot;sex&quot; /&gt;男&lt;input type = &quot;radio&quot; name = &quot;sex&quot; /&gt;女 &lt;br /&gt;&lt;!-- 单选框 如果是一组，使用相同的name值来实现 --&gt;爱 好：&lt;input type = &quot;checkbox&quot; name = &quot;hobby&quot; checked = &quot;checked&quot;&gt;足球&lt;input type = &quot;checkbox&quot; name = &quot;hobby&quot;&gt;篮球&lt;input type = &quot;checkbox&quot; name = &quot;hobby&quot;&gt;乒乓球 &lt;br /&gt;&lt;!-- 复选框 checked默认已选 --&gt;按 钮：&lt;input type = &quot;botton&quot; value = &quot;搜索&quot; /&gt; &lt;br /&gt; &lt;!-- 普通按钮 --&gt;&lt;input type = &quot;submit&quot; value = &quot;提交&quot; /&gt; &lt;!-- 提交按钮 value有默认值 --&gt;&lt;input type = &quot;reset&quot; value = &quot;重置表单&quot; /&gt; &lt;br /&gt; &lt;!-- 重置按钮 --&gt;&lt;input type = &quot;image&quot; src = &quot;ing.jpg&quot; /&gt; &lt;br /&gt; &lt;!-- 图像按钮 --&gt;上传头像：&lt;input type = &quot;file&quot; /&gt; &lt;!-- 文件按钮 可上传文件 --&gt; label标签（理解）label标签为input元素定义标注（标签）。 作用：用于绑定一个表单元素，当点击label标签时候，被绑定的表单元素就会获得输入焦点。 123456789&lt;!-- label标签的使用 --&gt;&lt;label&gt;输入账号：&lt;input type = &quot;text&quot; /&gt;&lt;/label&gt; &lt;br /&gt;&lt;!-- 指定表单元素，通过for和id进行配置 --&gt;&lt;label for = &quot;two&quot;&gt;第二个表单元素获得输入焦点：&lt;input type = &quot;text&quot; /&gt;&lt;input type = &quot;text&quot; id = &quot;two&quot;/&gt;&lt;/label&gt; &lt;br /&gt;&lt;!-- 或者将label和input标签分开 --&gt;&lt;label for = &quot;male&quot;&gt;Male&lt;/label&gt;&lt;input type = &quot;radio&quot; name = &quot;sex&quot; id = &quot;male&quot; value = &quot;male&quot; /&gt; textarea控件（文本域）如果需要输入大量的信息，就需要用到textarea标签。通过textarea可以轻松创建多行文本输入框，基本语法如下： 123&lt;textarea cols = &quot;每行中的字符数&quot; rows = &quot;显示的行数&quot;&gt; 文本内容&lt;/textarea&gt; 例如：12345留言板：&lt;textarea&gt; 请输入留言内容···&lt;/textarea&gt;&lt;!-- 文本域的大小一般使用CSS来调整 --&gt; 下拉菜单使用select控件定义下拉菜单的基本语法： 123456&lt;select&gt; &lt;option&gt;选项一&lt;/option&gt; &lt;option&gt;选项二&lt;/option&gt; &lt;option selected = &quot;selected&quot;&gt;选项三&lt;/option&gt; ···&lt;/select&gt; 注意：1、select中至少应包含一个option。2、在option中定义selected = “selected”时当前项为默认选中项。 表单域在HTML中，form标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递。form中的所有内容都会提交给服务器。创建表单的基本语法格式如下： 123&lt;form action = &quot;URL地址&quot; method = &quot;提交方式&quot; name = &quot;表单名称&quot;&gt; 各种表单控件&lt;/form&gt; 常用属性：1、action 在表单收集到信息后，需要把信息传给服务器进行处理，action属性用于指定接收并处理表单数据的服务器程序的URL地址。2、method 用于设置表单数据的提交方式，其取值为get或post。3、name 用于指定表单的名称，以区分同一个页面中的不同表单。 注意：每个表单都应该有自己的表单域。 HTML5新标签与特性常用新标签·header：定义文档的页眉、头部。·nav：定义导航链接的部分、导航栏。·footer：定义文档或节的页脚、底部。·article：定义文章。·section：定义文档中的节。·aside：定义所处内容之外的内容、侧边栏。 datalist标签作用：定义选项列表，一般与input标签一起使用。 12345678&lt;input type = &quot;text&quot; value = &quot;输入明星&quot; list = &quot;star&quot; /&gt;&lt;datalist id = &quot;star&quot;&gt; &lt;!-- 在input里使用list属性，在datalist里使用id属性 --&gt; &lt;option&gt;刘德华&lt;/option&gt; &lt;option&gt;刘若英&lt;/option&gt; &lt;option&gt;刘晓庆&lt;/option&gt; &lt;option&gt;郭富城&lt;/option&gt; &lt;option&gt;张学友&lt;/option&gt;&lt;/datalist&gt; fieldset标签作用：将表单内相关元素分组打包，一般与legend搭配使用。 12345&lt;fieldset&gt; &lt;legend&gt;用户登录&lt;/legend&gt; 用户名：&lt;input type = &quot;text&quot; /&gt; &lt;br/&gt; 密 码：&lt;input type = &quot;password&quot; /&gt;&lt;/fieldset&gt; HTML5新增的input type属性值 类型 使用示例 含义 email &lt;input type = &quot;email&quot; /&gt; 输入邮箱格式 tel &lt;input type = &quot;tel&quot; /&gt; 输入手机号码格式 url &lt;input type = &quot;url&quot; /&gt; 输入URL格式 number &lt;input type = &quot;number&quot; /&gt; 输入数字格式 search &lt;input type = &quot;search&quot; /&gt; 搜索框（体现语义化） range &lt;input type = &quot;range&quot; /&gt; 自由拖动滑块 time &lt;input type = &quot;time&quot; /&gt; 小时和分钟 date &lt;input type = &quot;date&quot; /&gt; 年月日 datetime &lt;input type = &quot;datetime&quot; /&gt; 时间 month &lt;input type = &quot;month&quot; /&gt; 年和月 week &lt;input type = &quot;week&quot; /&gt; 年和星期 color &lt;input type = &quot;color&quot; /&gt; 选择颜色 常用新属性 属性 使用示例 含义 placeholder &lt;input type = &quot;text&quot; placeholder = &quot;请输入用户名&quot; /&gt; 占位符，输入时文字消失，删除所有文字复原 autofocus &lt;input type = &quot;text&quot; aotofocus = &quot;aotofocus&quot; /&gt; 当页面加载时，input元素自动获得焦点 multiple &lt;input type = &quot;file&quot; multiple = &quot;multiple&quot; /&gt; 多文件上传 aotocomplete &lt;input type = &quot;text&quot; aotocomplete = &quot;on&quot; name = &quot;userName&quot; /&gt; 表单是否启用记录功能，on代表记录已经输入的值，off代表不记录 required &lt;input type = &quot;text&quot; required /&gt; 必填项 accesskey &lt;input type = &quot;text&quot; accesskey = &quot;s&quot;&gt; 规定激活（使元素获得焦点）的快捷键为“alt+s”的形式 aotocomplete的使用：12345&lt;form action = &quot;#&quot;&gt; 姓名：&lt;input type = &quot;text&quot; aotoconplete = &quot;on&quot; name = &quot;userName&quot; /&gt; &lt;input type = &quot;submit&quot; /&gt;&lt;/form&gt;&lt;!-- 1、需要提交按钮 2、必须有name属性（给表单提供名字） --&gt; 多媒体标签多媒体embed（会使用）embed可以用来插入各种多媒体，格式可以是Midi、Wav、AIFF、AU、MP3等等。URL为音频或视频文件的路径。 多媒体audioHTML5通过audio标签来解决音频播放问题。 1&lt;audio src = &quot;music/see you again.mp3&quot; autoplay = &quot;autoplay&quot; controls = &quot;controls&quot; loop = &quot;2&quot; &gt;&lt;/audio&gt; autoplay：自动播放controls：是否显示默认播放控件。loop：循环播放，loop = “2”播放两次，loop = “-1”无限循环。 为了浏览器兼容，代码一般这样写： 1234567&lt;!-- 音频支持mp3、wav、ogg格式--&gt;&lt;audio controls&gt; &lt;source src = &quot;music.mp3&quot; /&gt; &lt;source src = &quot;music.wav&quot; /&gt; &lt;source src = &quot;music.ogg&quot; /&gt; 您的浏览器不支持播放HTML音频文件&lt;/audio&gt; 多媒体video基本用法： 1&lt;video src = &quot;movie.mp4&quot; controls = &quot;controls&quot; autoplay = &quot;autoplay&quot;&gt;&lt;/video&gt; 属性：autoplay、controls、loop，用法与audio相同。width、height，控制视频窗口的大小。 1234567&lt;!-- 音频支持MP4、ogg、webM 格式 --&gt;&lt;video controls = &quot;controls&quot;&gt; &lt;source src = &quot;movoie.mp4&quot; /&gt; &lt;source src = &quot;movoie.ogg&quot; /&gt; &lt;source src = &quot;movoie.webM&quot; /&gt; 您的浏览器不支持播放HTML视频文件&lt;/video&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象（下）]]></title>
    <url>%2F2019%2F04%2F26%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%8B)%2F</url>
    <content type="text"><![CDATA[继承继承的实现继承让我们更加容易实现类的扩展。例如，我们定义了动物类，再定义哺乳动物类只需要扩展动物类即可，实现了代码的重用。 12345678910111213141516171819202122232425public class TestExtends&#123; public static void main(String[] args)&#123; Student stu = new Student(); stu.name = &quot;Tom&quot;; stu.height = 172; stu.rest(); &#125;&#125;class Person&#123; String name; int height; public void rest()&#123; System.out.println(&quot;休息一下！&quot;); &#125;&#125;class Student extends Person&#123; //继承关键字 String major; public void study()&#123; System.out.println(&quot;学习一会儿！&quot;); &#125;&#125; 继承的要点：1、父类也称作超类、基类等。2、Java中只有单继承，没有像C++那样的多继承，多继承会引起混乱，使得继承链复杂。3、Java中类没有多继承，接口有多继承。‘4、子类继承父类，可以得到父类的全部属性和方法（除了父类的构造方法），但不见得可以直接访问（比如父类私有的属性和方法）。5、如果一个类没有调用extends，则父类为java,lang.Object。 instanceof运算符instanceof是二元运算符，左边是对象，右边是类。当对象是右边类或子类所创建的对象时，返回true，否则返回false。 123456789public class Test&#123; public static void main(String[] args)&#123; Student s = new Student(); Person p = new Person(); System.out.println(&quot;s instanceof Person&quot;); //true System.out.println(&quot;s instanceof Student&quot;); //true System.out.println(&quot;p instanceof Student&quot;); //false &#125;&#125; 方法的重写override子类通过重写父类的方法，可以用自身的行为替换父类的行为。方法的重写是实现多态的必要条件。 方法重写的要点：1、方法名，形参列表相同。2、返回值类型和声明异常类型，子类小于等于父类。3、访问权限，子类大于等于父类。 123456789101112131415161718192021222324252627282930313233343536373839public class TestOverride&#123; public static void main(String[] args)&#123; Vehicle v1 = new Vehicle(); Vehicle v2 = new Horse(); Vehicle v3 = new Plane(); v1.run(); v2.run(); v3.run(); v2.stop(); v3.stop(); &#125; class Vehicle&#123; public void run()&#123; System.out.println(&quot;跑···&quot;)； &#125; public void stop()&#123; System.out.println(&quot;停止不动！&quot;); &#125; &#125; class Horse extends Vehicle&#123; public void run()&#123; System.out.println(&quot;四蹄翻飞，嘚嘚嘚嘚···&quot;); &#125; &#125; class Plane extends Vehicle&#123; public void run()&#123; System.out.println(&quot;天上飞!&quot;)； &#125; public void stop()&#123; System.out.println(&quot;空中不能停！&quot;); &#125; &#125;&#125; Object类Object类是所有Java类的根基类，所有Java对象都拥有Object类的属性和方法。 toString()方法Object类中定义有public String toString()方法，返回值类型为String。 1234//toString 源码public String toString()&#123; return getClass.getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125; 123456789101112131415161718192021toString()测试和重写toString方法class Person&#123; String name; int age; @Override public String toString()&#123; return name + &quot;年龄：&quot; + age; &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; Person p = new Person(); p.age = 18; p.name = &quot;Tom&quot;; System.out.println(&quot;Info:&quot; + p); //调用Person的toString方法 Test t = new Test(); System.out.println(t); //调用Object的toString方法 &#125;&#125; “==”和equals()方法== 代表比较双方是否相同。如果是基本类型则表示值相等，如果是引用类型则表示地址相等，即是同一个对象。 Object类中定义有public boolean eaquals(Object obj)方法，提供定义对象内容相等的逻辑。 1234//equals源码public boolean equals(Object obj)&#123; return (this == obj);&#125; 1234567891011121314151617181920212223//String类中对equals方法的重写public boolean equals(Object anObject)&#123; if(this == anObject)&#123; return true; &#125; if(anObject instanceof String)&#123; String anotherString = (String)anObject; int n = value.length; if( n == anotherString.value.length)&#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while(n-- != 0)&#123; if(v1[i] != v2[i])&#123; return false; &#125; i++; &#125; return ture; &#125; &#125; return false;&#125; 123456789101112131415161718192021222324252627282930313233343536373839//equals方法测试和自定义类重写equals方法public class TestEquals&#123; public static void main(String[] args)&#123; Person p1 = new Person(123,&quot;Tom1&quot;); Person p2 = new Person(123,&quot;Tom2&quot;); System.out.println(p1 == p2); //false System.out.println(p1.equals(p2)); //id相同，true String s1 = new String(&quot;qwer&quot;); String s2 = new String(&quot;qwer&quot;); System.out.println(s1 == s2); //false，地址不同 System.out.println(s1.equals(s2)); //true，字符串内容相同 &#125;&#125;class Person&#123; int id; String name; public Person(int id, String name)&#123; this.id = id; this.name = name; &#125; public boolean equals(Object obj)&#123; if(obj == null)&#123; return false; &#125; else&#123; if(obj instanceof Person)&#123; Person c = (Person)obj; if(c.id == this.id)&#123; return true; &#125; &#125; &#125; return false; &#125;&#125; super关键字super的使用super是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性。 若使用super调用普通方法，语句没有位置限制，可以在子类中直接调用。 若是构造方法的第一行没有显式地调用super(…)或this(…)，Java默认会调用super().调用父类的无参数构造方法，可以省略。 12345678910111213141516171819202122232425//super关键字的使用public class TestSuper&#123; public void main(String[] args)&#123; new ChildClass.f(); &#125;&#125;class FatherClass&#123; public int value; public void f()&#123; value = 100; System.out.println(&quot;FatherClass.value = &quot; + value); &#125;&#125;class ChildClass extends FatherClass&#123; public int value; public void f()&#123; super.f(); value = 200; System.out.println(&quot;ChileValue = &quot; + value); System.out.println(value); System.out.println(super.value); &#125;&#125; 继承树的追溯属性/方法查找顺序：（比如查找变量V）1、查找当前类中有没有属性V。2、依次上溯每个父类，查看每个类中是否有属性V，直到Object。3、没有找到，出现编译错误。4、只要找到变量V，过程停止。 构造方法调用顺序：构造方法第一句总是super()来调用父类对应的构造方法。先上溯到Object，然后再依次向下执行类的初始化块和构造方法，直到当前子类为止。静态初始化块调用顺序和构造方法调用顺序一样（Java面向对象（上）中有相关介绍）。 1234567891011121314151617181920//构造方法上溯执行测试public class TestSuper&#123; public void main(String[] args)&#123; System.out.println(&quot;开始创建一个ChildClass对象···&quot;); new ChildClass(); &#125;&#125;class FatherClass&#123; pubic FatherClass()&#123; System.out.println(&quot;创建FatherClass&quot;); &#125;&#125;class ChildClass extends FatherClass&#123; public ChildClass()&#123; //该行自动调用父类无参构造方法 System.out.println(&quot;创建ChildClass&quot;); &#125;&#125; 封装封装的作用及含义我们程序设计要追求“高内聚，低耦合”。高内聚就是内部的数据操作细节自己完成，不允许外部干涉，低耦合是仅暴露少量的方法给外部使用，尽量方便外部调用。 编程中封装的具体优点：1、提高代码的安全性。2、提高代码的复用性。3、高内聚，便于修改内部代码，提高可维护性。4、低耦合，便于调用者使用，便于扩展和协作。 使用访问控制符实现封装Java是使用“访问控制符”类控制哪些细节需要封装，哪些需要暴露的。 1、private表示私有，只有自己能访问。2、default表示没有修饰符修饰，只有同一个包的类能访问。3、protected表示可以被同一个包的类以及其他包的子类访问。4、public表示可以被该项目的所有包的所有类访问。 封装的使用细节类属性的处理：1、一般使用private访问权限。2、提供相应的set和get方法来访问相关属性，方法是public修饰的，提供属性的访问和读写操作。3、一些只用于本类辅助性方法可以用private修饰，希望其他类调用的方法用public修饰。 123456789101112131415161718192021222324252627282930//JavaBean的封装实例public class Person&#123; private String name; private int age; private boolean man; //属性使用private修饰 public String getName()&#123; return this.name; &#125; public void setName(String name)&#123; this.name = name; &#125; public int getAge()&#123; return this.age; &#125; public void setAge(int age)&#123; this.age = age; &#125; public boolean isMan()&#123; //boolean类型的get方法是is开头 return man; &#125; public void setMan(boolean man)&#123; this.man = man; &#125;&#125; 多态（polymorphism）多态的概念多态指的是同一个方法的调用，由于对象不同可能会有不同的行为。现实生活中，同一个方法，具体实现会完全不同。 多态的要点：1、多态是方法的多态，不是属性的多态（多态与属性无关）。2、多态的存在条件有三个必要条件：继承、方法重写、父类引用指向子类对象。3、父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了。 对象的转型（casting）父类指向引用子类的对象，我们称这个过程为向上转型，属于自动类型转换。 向上转型后的父类引用变量只能调用它编译类型的方法，不能调用它运行时类型的方法。这是我们需要进行强制类型转换，称之为向下转型。 123456789101112131415161718192021222324252627282930313233343536373839404142//测试多态和转型public class TestPolymorphism&#123; public static void main(String[] args)&#123; animalCry(new Animal); Animal d = new Dog(); //向上可以自动转型 animalCry(d); //Animal中的shout方法 //d.seeDoor(); //报错 Dog _d = (Dog)d; //向下转型 _d.seeDoor(); //Cat c = (Dog)d; //类型不匹配 animalCry(new Cat()); //Cat中shout方法 &#125; static animalCry(Animal a)&#123; a.shout(); &#125;&#125;class Animal&#123; public void shout()&#123; System.out.println(&quot;叫了一声！&quot;); &#125;&#125;class Dog extends Animal&#123; public void shout()&#123; System.out.println(&quot;汪汪汪！&quot;); &#125; public void seeDoor()&#123; System.out.println(&quot;看门!&quot;)； &#125;&#125;class Cat extends Animal&#123; public void shout()&#123; System.out.println(&quot;喵喵喵！&quot;); &#125;&#125; final关键字final关键字的作用：1、修饰变量：被修饰的变量不可改变。一旦赋初值，就不可被改变。1final int MAX_SPEED = 120; 2、修饰方法：该方法不可被子类重写，但是可以重载。1final void study()&#123;&#125; 3、修饰类：修饰类不能被继承，比如：Math、String等。1final class A&#123;&#125; 抽象方法和抽象类抽象方法使用abstract修饰的方法，没有方法体，只有声明。定义的是一种规范，就是告诉子类必须要给抽象方法具体的实现。 抽象类包含抽象方法的类就是抽象类。通过abstract方法定义规范，然后要求子类必须定义具体实现。通过抽象类，我们就可以严格限制子类的设计，使子类之间更加通用。 1234567891011121314151617181920212223//抽象类和抽象方法的基本使用abstruct class Animal&#123; //抽象类 abstruct public void shout(); //抽象方法&#125;class Dog extends Animal&#123; //子类必须实现父类的抽象方法，否则编译错误 public void shout()&#123; System.out.println(&quot;汪汪汪！&quot;); &#125; public void seeDoor()&#123; System.out.println(&quot;看门中···&quot;); &#125;&#125;public class TestAbstructClass&#123; public static void main(String[] args)&#123; Dog a = new Dog(); a.shout(); a.seeDoor(); &#125;&#125; 抽象类的使用要点1、有抽象方法的类只能定义成抽象类。2、抽象类不能被实例化，即不能用new来实例化抽象类。3、抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用。4、抽象类只能用来被继承。5、抽象方法必须被子类实现。 接口什么是接口（抽象类和接口的对比）接口就是比“抽象类”还抽象的“抽象类”，可以更加规范的对子类进行约束。全面而专业的实现了：规范和具体实现的分离。 抽象类还提供某些具体实现，接口不提供任何实现，接口中所有方法都是抽象方法。接口是完全面向规范的，规定了一批类具有的公共方法规范。 接口是两个模块之间通信的标准，通信的规范。如果能把你要设计的模块之间的接口定义好，就相当于完成了系统的设计大纲，剩下的就是具体实现了。 接口和实现类不是父子关系，是实现规则的关系。比如：定义一个Runnable接口，Car实现它就能在地上跑，Train实现它也能在地上跑。如果它是交通工具就一定能跑，但是必须实现Runnable接口。 如何定义和使用接口12345//声明格式[访问修饰符] interface 接口名 [extends 父接口1、父接口2···]&#123; 常量定义; 方法定义;&#125; 定义接口的详细说明：1、访问修饰符：只能是public或默认。2、接口名：和类名采用相同命名机制。3、extends：接口可以多继承。4、常量：接口中的属性只能是常量，总是public static final修饰。不写也是。5、方法：接口中的方法只能是public abstract。省略也是。 要点：1、子类通过implements来实现接口中的规范。2、接口不能创建实例，但是可以用于声明引用变量类型。3、一个类实现了接口，必须实现接口中所有方法，并且方法只能是public。 12345678910111213141516171819202122232425262728293031323334353637383940//接口的使用public class TestInterface &#123; public static voic main(String[] args)&#123; Volant v = new Angle(); v.fly(); System.out.println(&quot;v.FLY_HEIGHT&quot;); Honest h = new GoodMan(); h.helpOther(); &#125;&#125;//飞行接口public interface Volant&#123; int FLY_HEIGHT = 100; //总是public static final类型的 void fly(); //总是public abstract void fly();&#125;//善良接口public interface Honest&#123; void helpOther();&#125;//Angle类实现飞行接口和善良接口class Angle implements Volant,Honest&#123; //多继承 public void fly&#123; System.out.println(&quot;我是天使，我会飞。&quot;); &#125; public void helpOther()&#123; System.out.println(&quot;帮助别人。&quot;); &#125;&#125;//GoodMan类实现Honest接口class GoodMan implements Honest&#123; public void helpOther()&#123; System.out.println(&quot;扶老奶奶过马路。&quot;); &#125;&#125; 面向接口编程面向接口编程是面向对象编程的一部分。 接口就是规范，是项目中最稳定的东西。面向接口编程让我们把握住最核心的东西，使实现复杂多变的需求成为可能。 通过面向接口编程，而不是面向实现类编程，可以大大降低程序模块之间的耦合性，提高整个系统的可扩展性和可维护性。 内部类在JAVA中内部类主要分为成员内部类（非静态内部类、静态内部类）、匿名内部类、局部内部类。 成员内部类成员内部类可以使用private、default、protected、public进行修饰。 非静态内部类外部类里使用非静态内部类和平时使用其他类没什么区别。 特点：1、非静态内部类必须寄存在一个外部类对象里。因此，如果存在一个非静态内部类对象那么一定存在对应的外部类对象。非静态内部类对象单独属于外部类的某个对象。2、非静态内部类可以直接访问外部类的成员，但是外部类不可以直接访问非静态内部类成员。3、非静态内部类不能有静态方法、静态属性和静态初始化块。4、外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例。5、成员变量访问要点： 1)内部类里方法的局部变量：变量名。 2)内部类属性：this.变量名。 3)外部类属性：外部类名.this.变量名。6、内部类的访问: 1)外部类中定义内部类：new Inner();。 2)外部类以外的地方使用非静态内部类：Outer.Inner varname = new Outer().new Inner();。 12345678910111213141516171819202122232425//测试非静态内部类public class TestInnerClass&#123; public static void main(String[] args)&#123; Outer.Inner inner = new Outer().new Inner(); //创建内部类对象 inner.show(); &#125;&#125;class Outer&#123; private int age = 10; public void testOuter()&#123; System.out.println(&quot;Outer.testOuter.&quot;); &#125; class Inner&#123; int age = 20; public void show()&#123; int age = 30; System.out.println(&quot;外部类的成员变量age:&quot; + Outer.this.age); //访问外部类属性 10 System.out.println(&quot;内部类的成员变量age:&quot; + this.age); //访问外部类属性 20 System.out.println(&quot;局部变量age:&quot; + age); //访问外部类属性 30 &#125; &#125;&#125; 静态内部类要点：1、当一个静态内部类对象存在，并不一定存在对应的外部类对象。因此，静态内部类的实例方法不能直接访问外部类的实例方法。2、静态内部类看作外部类的一个静态成员。因此，外部类的方法中可以通过：“静态内部类.名字”的方式访问静态内部类的成员变量，通过new 静态内部类()访问静态内部类的实例。 123456789101112//静态内部类的访问class Outer&#123; static class Inner&#123; //相当于外部类的静态成员 &#125;&#125;public class TestStaticInnerClass&#123; public static void main(String[] args)&#123; //通过new 外部类.内部类()来创建内部类对象 Outer.Inner inner = new Outer.Inner(); &#125;&#125; 匿名内部类适合只需要使用一次的类。比如：监听键盘操作等等。 语法：123new 父类构造器(实参)\实现接口()&#123; 匿名内部类类体&#125; 123456789101112131415161718//匿名内部类的使用this.addWindowListener(new WindowAdapter()&#123; @Override public void windowClosing(WindowEvent e)&#123; System.exit(0); &#125;&#125;);this.addKeyListener(new KeyAdapter()&#123; @Override public void keyPressed(KeyEvent e)&#123; myTank.keyPressed(e); &#125; @Override public void keyReleased(KeyEvent e)&#123; myTank.keyReleased(e); &#125;&#125;); 注意：1、匿名内部类没有访问修饰符。2、匿名内部类没有构造方法。 局部内部类局部内部类定义在方法内部，作用域仅限于本方法。 1234567891011121314public class Test&#123; public void show()&#123; class Inner&#123; //作用于仅限于本方法 public void fun()&#123; System.out.println(&quot;局部内部类&quot;); &#125; &#125; new Inner().funn(); &#125; public static void main(String[] args)&#123; new Test().show(); &#125;&#125; String基础String类基本特点1、String类又称作不可变字符序列。2、String位于java.lang包中，java程序默认导入java.lang中的所有类。3、Java字符串就是Unicode字符序列。4、Java没有内置字符串类型，而是在标准Java类库里提供预定义的类String，每个用双引号括起来的字符串都是String类的一个实例。5、Java允许使用“+”将字符串连接。 String类和常量池在Java的内存分析中，我么你经常会听到关于“常量池”的描述，实际上常量是分为一下三种：1、全局字符串常量池（String Pool） 全局字符串常量池中存放的内容是在类加载完成后存到String Pool中的，在每个VM中只有一份，存放的是字符串常量的引用值（在堆中生成字符串对象实例）。2、class文件常量池（Class Constant Pool） class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量（文本字符串、final常量等）和符号引用。3、运行时常量池（Runtime Constant Pool） 运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。 1234567891011//常量池public class Test&#123; public static void main(String[] args)&#123; String str1 = &quot;Tom&quot;; String str2 = &quot;Tom&quot;; String str3 = new String(&quot;Tom&quot;); System.out.println(str1 == str2); //true，Tom放在常量池中，同一个对象 System.out.println(str1 == str3); //false，新建的对象 &#125;&#125; 因此：通常比较字符串时，使用equals。 String类常用方法 方法 解释说明 char charAt(int index) 返回字符串中第index个字符 boolean equals(String other) 如果字符串与other相等，返回true；否则返回false boolean equalsIgnoreCase(String other) 如果字符串与other相等（忽略大小写），返回true；否则返回false int indexOf(String str) 返回从头开始查找第一个子字符串str在字符串中的索引位置。如果未找到字符串str，返回-1 int lastIndexOf(String str) 返回从末尾开始查找第一个子字符串str在字符串中的索引位置。如果未找到字符串str，返回-1 int length() 返回字符串的长度 String replace(char oldChar, char newChar) 返回一个新串，通过用newChar替换此字符串中出现的所有oldChar而生成的 boolean startsWith(String prefix) 如果字符串以prefix开始，返回true boolean endsWith(String prefix) 如果字符串以prefix结尾，返回true String substring(int beginIndex) 返回一个新字符串，该串包含从原始字符串beginIndex到串尾 String substring(int beginIndex, int endIndex) 返回一个新字符串，该串包含从原始字符串beginIndex到endIndex-1的所有字符 String toLowerCase() 返回一个新字符串，为原始字符串的小写 String toUpperCase() 返回一个新字符串，为原始字符串的大写 String trim() 返回一个新字符串，该串删除了原始字符串的头部和尾部的空格 数组数组概述和特点数组是相同类型数据的有序集合。 数组的三个基本特点：1、长度是确定的。数组一旦被创建，大小就无法改变。2、其元素类型必须相同，不允许出现混合类型。3、数组类型可以是任何类型，包括基本类型和引用类型。 数组也是对象，存储在堆里，数组变量属于引用类型，数组中的每个元素相当于该对象的成员变量。 数组的声明1234567891011//创建基本类型一维数组public class Test&#123; public static void main(String[] args)&#123; int[] s = null; //声明数组 s = new int[10]; //给数组分配空间（堆内存） for(int i = 0; i &lt; 10; i++)&#123; s[i] = i; //给元素赋值 System.out.println(s[i]); &#125; &#125;&#125; 1234567891011121314151617181920212223//创建引用类型一维数组class Man&#123; private int age; private int id; public Man(int age, int id)&#123; super(); this.age = age; this.id = id; &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; Man[] mans; //声明引用类型数组 mans = new Man[10]; //给数组分配空间 Man m1 = new Man(1,11); Man m2 = new Man(2,22); mans[0] = m1; mans[1] = m2; &#125;&#125; 数组的初始化数组的初始化一共有三种：静态初始化、动态初始化、默认初始化。 静态初始化除了用new关键字来产生数组以外，还可以直接在定义数组的同时就为数组元素分配空间并赋值。 123//静态初始化int[] a = &#123;1, 2, 3&#125;; //静态初始化基本类型数组Man[] mans = &#123;new Man(1,1), new Man(2,2)&#125;; //静态初始化引用类型数组 动态初始化数组的定义与为数组元素分配空间并赋值的操作分开进行。 1234//动态初始化数组int[] a = new int[2]; //先分配空间a[0] = 1; //给数组元素赋值a[1] = 2; 默认初始化数组是引用类型，它的元素相当于类的实例变量因此数组一经分配空间，其中每个元素也被按照实例变量同样的方式被隐性初始化。 123int[] i = new int[2]; //默认值0boolean[] b = new boolean[2]; //默认值falseString[] s = new String[2]; //默认值null 数组的遍历数组元素下标合法区间：[0,length-1]。我们可以通过下标来遍历数组的元素，遍历时可以读取元素的值或者修改元素的值。 使用循环遍历数组12345678910111213public class Test&#123; public static void main(String[] args)&#123; int[] a = new int[4]; //初始化数组 for(int i = 0; i &lt; a.length; i++)&#123; a[i] = i*100; &#125; //读取元素的值 for(int i = 0; i &lt; a.length; i++)&#123; System.out.println(a[i]); &#125; &#125;&#125; for-each循环for-each循环专门用来读取数组或集合的所有元素，即对数组进行遍历。 12345678public class Test&#123; public static void main(String[] args)&#123; String[] s = &#123;&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;&#125;; for(String temp : s)&#123; System.out.println(temp); &#125; &#125;&#125; 注意：只能读取元素的值，不能修改元素的值。 数组的拷贝System类里包含一个static void arraycopy(object src, int srcpos, object dest, int destpos, int length)方法，该方法可以将src数组里的元素值赋值给dest数组的元素，srcpos指定从src数组的第几个元素开始赋值，length参数指定将src数组的多少个元素赋给dest数组的元素。 12345678910public class Test&#123; public static void main(String[] args)&#123; String[] s = &#123;&quot;阿里&quot;, &quot;京东&quot;, &quot;搜狐&quot;, &quot;网易&quot;&#125;； String[] sCopy = new String[6]; System.arraycopy(s, 0, sCopy, 0, s.length); for(int i = 0; i &lt; sCopy.length; i++)&#123; System.out.println(sCopy[i]); &#125; &#125;&#125; java.util.Arrays类Arrays类，包含了常用的数组操作，方便我们日常开发。Arrays类包含了：排序、查找、填充、打印内容的操作。 打印数组12345678import java.util.Arrays;public class Test&#123; public static void main(String[] args)&#123; int[] a = &#123;1, 2&#125;; System.out.println(a); //打印数组引用的值 System.out.println(Arrays.toString(a)); //打印数组元素的值 &#125;&#125; 注意：此处的Arrays.toString方法是Arrays类的静态方法，不是前面的Object的toString方法。 数组元素排序12345678910//基本类型的排序import java.util.Arrays;public class Test&#123; public static void main(String[] args)&#123; int[] a = &#123;1,3,6,5,2,8,5,3,7&#125;; System.out.println(Arrays.toString(a)); Arrays.sort(a); System.out.println(Arrays.toString(a)); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536//引用类型的排序import java.util.Arrays;public class Test&#123; public static void main(String[] args)&#123; Man[] msMans = &#123;new Man(1, &quot;a&quot;), new Man(2, &quot;b&quot;), new Man(3, &quot;c&quot;)&#125;; Arrays.sort(msMans); System.out.println(Arrays.toString(msMans)); &#125; class Man implements Comparable&#123; //需实现此接口 int age; int id; String name; public Man(int age, String name)&#123; super(); this.age = age; this.name = name; &#125; public String toString()&#123; return this.name; &#125; public int compareTo(Object o)&#123; //重写compareTo方法 Man man = (Man)o; if(this.age &lt; man.this)&#123; return -1; &#125; if(this.age &gt; this.age)&#123; return 1; &#125; return 0; &#125; &#125;&#125; 二分查找12345678import java.util.Arrays;public class Test&#123; public static void main(String[] args)&#123; int[] a = &#123;1, 3, 7, 2, 4, 6, 3, 1, 4&#125;; Arrays.sort(a); //使用二分查找许先排序 System.out.println(&quot;该元素索引：&quot; + Arrays.binarySearch(a, 2)); &#125;&#125; 多维数组二维数组的声明： 123456789public class Test&#123; public static void main(String[] args)&#123; //Java中多维数组声明和初始化应该从低维到高维 int[][] a = new int[3][]; a[0] = new int[2]; a[1] = new int[3]; a[2] = new int[4]; &#125;&#125; 二维数组的静态初始化： 123456public class Test&#123; public static void main(String[] args)&#123; int[][] a = &#123;&#123;1, 2, 3&#125;, &#123;3, 4, 5, 6&#125;, &#123;2, 4&#125;&#125;; System.out.println(a[2][3]); &#125;&#125; 二维数组的动态初始化： 123456789101112import java.util.Arrays;public class Test&#123; public static void main(String[] args)&#123; int[][] a = new int[3][]; a[0] = new int[] &#123;1, 2&#125;; a[1] = new int[] &#123;3, 4, 5&#125;; a[2] = new int[] &#123;4, 5, 6, 7&#125;; System.out.println(Arrays.toString(a[0])); System.out.println(Arrays.toString(a[1])); System.out.println(Arrays.toString(a[2])); &#125;&#125; 冒泡排序的基础算法123456789101112131415161718192021import java.util.Arrays;public class Test&#123; public static void main(String[] args)&#123; int[] values = &#123;5, 3, 6, 2, 4, 7, 8, 2, 5, 0&#125;; bubbleSort(values); System.out.println(Arrays.toString(values)); &#125;&#125;public static void bubbleSort(int[] values)&#123; int temp; for(int i = 1; i &lt; values.length; i++)&#123; for(int j = 0; j &lt; values.length - i; j++)&#123; if(values[j] &gt; values[j+1])&#123; temp = values[j]; values[j] = values[j+1]; values[j+1] = temp; &#125; &#125; &#125;&#125; 二分法查找1234567891011121314151617181920212223242526272829import java.util.Arrays;public class Test&#123; public static void main(String[] args)&#123; int[] arr = &#123;3, 5, 8, 2, 3, 5, 32, 87, 54, 43, 54&#125;; int searchWord = 32; Arrays.sort(arr); //使用二分法先将数组进行排序 System.out.println(Arrays.toString(arr)); System.out.println(searchWord+&quot;元素索引：&quot;+binarySearch(arr,searchWord)); &#125;public static int binarySearch(int[] array, int value)&#123; int low = 0; int high = array.length - 1; while(low &lt;= high)&#123; int mid = (low + high) / 2; if(value == array[mid])&#123; return mid; &#125; if(value &gt; array[mid])&#123; low = mid + 1; &#125; if(value &lt; array[mid])&#123; high = mid - 1; &#125; &#125; return -1; //未找到 &#125;&#125;]]></content>
      <categories>
        <category>Java知识体系</category>
      </categories>
      <tags>
        <tag>Java知识体系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象（上）]]></title>
    <url>%2F2019%2F04%2F23%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[对象和类对象和类的概念对象是个内存块，里面放相关联的数据和相关方法。类可以看作是对象的模板，或者图纸，系统根据类的定义来造出对象。对象我们叫做Object，instance（实例）。类我们叫class。 定义一个类12345678910// 类的定义方式public class Car&#123; //每一个源文件必须有且只有一个public class，并且该类名和文件名保持一致。 ···&#125;class Type&#123; //一个Java文件可以定义多个class。 ···&#125;class Engine&#123; ···&#125; 对于一个类来说，一般有三种常见的成员：属性field、方法method、构造器constructor。这三种成员都可以定义零个或多个。 1234567891011121314151617//简单的学生类编写public class Student&#123; //属性（成员变量） int id; String name; int age; //方法 void study()&#123; System.out.println(&quot;我正在学习！&quot;); &#125; //构造方法 无参构造方法可以由系统自动创建 Student()&#123; &#125;&#125; 属性：也叫成员变量，用于定义该类或该类对象的静态特征。属性的作用范围是整个类体。方法：用于定义该类或该类实例的行为特征和功能实现，面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。 面向对象的内存分析Java虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area。 12345678910111213141516171819202122232425262728293031323334示例代码：Student.javapublic classs Student&#123; int id; String name; int age; Computer comp; void study()&#123; System.out.println(&quot;我正在学习！&quot;); &#125; viod play()&#123; System.out.println(&quot;我正在玩游戏！使用&quot;+comp.brand+&quot;电脑。&quot;); &#125; public static void main(String[] args)&#123; Student stu = new Student(); sdu.id = 101; stu.name = &quot;Tom&quot;; stu.age = 18; Computer c1 = new Computer; c1.brand = &quot;HP&quot;; stu.comp = c1; stu.play(); stu.study(); &#125;&#125;class Computer&#123; String brand;&#125; 栈栈的特点：1、栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧（存储局部变量、操作数、方法出口等)。2、JVM为每个线程创建一个栈，用于存放该线程执行方法的信息（实际参数、局部变量等）。3、栈属于线程私有，不能实现线程间的共享。4、栈的存储特点是“先进后出，后进先出”。5、栈是由系统自动分配，速度快，栈是连续的内存空间。 堆堆的特点：1、堆用于存储创建好的对象和数组（数组也是对象）。2、JVM只有一个堆，被所有线程共享。3、堆是一个不连续的内存空间，分配灵活，速度慢。 方法区方法区（静态区）的特点：1、JVM只有一个方法区，被所有线程共享。2、方法去实际也是堆，只是用于存储类、常量相关的信息。3、用来存放程序中永远是不变或唯一的内容（类信息，即class对象、静态变量、字符串常量等）。 构造器概念构造器也叫构造方法（constructor），用于对象的初始化。 要点：1、通过new关键字调用。2、构造器虽然有返回值，但是不能定义返回值类型，不能用return返回某个值。3、如果没有定义构造器，编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加。4、构造器的方法名必须和类名一致。 构造器的重载构造器的重载和方法的重载类似，同名不同参的构造方法可以在一个类中定义多个。 123456789101112131415161718192021222324252627public class User&#123; int id; String name; String password; public User()&#123; &#125; public User(int id,String name)&#123; super(); //构造方法的第一句总是super(); this.id = id; //this表示创建好的对象。 this.name = name; &#125; public User(int id,String name,String password)&#123; super(); this.id = id; this.name = name; this.password = password; &#125; public static void main(String[] args)&#123; User u1 = new User(); User u2 = new User(100,Tom); User u2 = new User(200,Alice,1234567); &#125;&#125; 垃圾回收机制（Garbage Collection）Java有垃圾回收机制这一特性，从而简化开发。 垃圾回收原理和算法内存管理：Java的内存管理很大程度指的是对象的管理，其中包括对象空间的分配和释放。对象空间的分配：使用new关键字创建对象即可。对象空间的释放：将对象赋值null即可。垃圾回收机制负责回收所有不可达对象的内存空间。 垃圾回收过程：任何一种垃圾回收算法一般要做两件事情：1、发现无用的对象。2、回收无用对象占用的内存空间。 垃圾回收相关算法： 1、引用计数法堆中每个对象都有一个引用计数。被引用一次计数加1，被引用变量值变为null，计数减1，直到计数为0，则表示变成无用对象。优点是算法简单，缺点是“循环引用的无用对象”无法识别。 123456789101112131415//循环引用示例public class Student &#123; String name; Student friend; public static void main(String[] args)&#123; Student s1 = new Student(); Student s2 = new Student(); s1.friend = s2; s2.friend = s1; s1 = null; s2 = null; &#125;&#125; s1和s2互相引用对方，导致计数不为零，但是实际上已经无用，但无法被识别。 2、引用可达法（根搜索算法） 程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点被认为是没有被引用的节点，即无用的节点。 通用分代垃圾回收机制分代垃圾回收机制，基于一个事实：不同的对象的生命周期是不同的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为Eden、Survivor和Tenured/Old空间。 1、年轻代所有新生成的对象首先放在Eden区。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。对应的是Minor GC，每次Minor GC会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作但是会浪费内存空间。当“年轻代”区域存满后，就将对象放在年老代区域。 2、年老代在年轻代中经历了N（默认15）次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启用Major GC和Full GC（全量回收），来一次大扫除，全面清理年轻代区域和年老代区域。 3、持久代用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。 ·Minor GC：用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用的对象，将有用对象复制到“Survivor1”、“Survivor2”区中（这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个区域在用，一个为空）。 ·Major GC：用于清理年老代区域。 ·Full GC：用于清理年轻代、年老代区域。成本较高，会对系统性能产生影响。 垃圾回收过程： 1、新创建的对象，绝大多数会被存放到Eden区。2、当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用的对象清理掉，然后剩余对象复制到某个Survivor中，如s1，同时清空Eden区。3、当Eden区再次满了，会将s1中不能清理的对象存到另外一个Survivor中，如s2，同时将Eden区不能清空的对象，也复制到s2中，保证Eden和s1被清空。4、重复多次（15次）Survivor中没有被清理的对象，则会被复制到老年代Old区中。5、当Old区满了，则会触发一次完整的垃圾回收（Full GC）。 this关键字创建对象的过程创建一个对象分为四步：1、分配对象空间，并将对象成员变量初始化为0或null。2、执行属性值的显式初始化。3、执行构造方法。4、返回对象的地址给相关变量。 this的本质this的本质是“创建好的对象的地址”，由于在构造方法调用前，对象已经创建。因此可以在构造方法中使用this代表当前对象。 this最常用法1、在程序产生二义性之处，应使用this指明当前对象。普通方法中，this指向调用该方法的对象，构造方法中，this指向正要初始化的对象。2、使用this关键字调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中使用，并且只能在构造方法的第一句。3、this不能用在static方法中（static方法存储位置不同）。 1234567891011121314151617181920212223//this指明对象public class TestThis&#123; int a,b,c; TestThis(int a,int b)&#123; this.a = a; //指明本对象的成员变量a this.b = b; &#125; TestThis(int a, int b, int c)&#123; this(a,b); //调用上面的构造器,且必须位于第一句 this.c = c; &#125; void sing()&#123; System.out.println(&quot;I&apos;m singing!&quot;); &#125; void eat()&#123; this.sing(); //调用本类sing方法 System.out.println(&quot;I&apos;m eating!&quot;); &#125;&#125; static关键字在类中，用static声明的成员变量是静态成员变量，也称为类变量。类变量的生命周期和类相同，在整个应用程序执行期间都有效。它有如下特点：1、为该类的公共变量，属于类，被该类的所有实例共享，在该类被载入时显式初始化。2、对于该类的所有对象来说，static成员变量只有一份。被该类的所有对象共享。3、一般用“类名.类属性/方法”来调用，也可以通过对象引用或类名（不需要实例化）访问静态成员。4、在static方法中不能直接访问非static的成员。 核心要点：static修饰的成员变量和方法从属于类，普通变量和方法从属于对象。 1234567891011121314151617181920212223242526272829//测试static用法public class User&#123; int id; String name; String password; static String company = &quot;腾讯&quot;; public User(int id, String name)&#123; this.id = id; //this代指对象 this.name = name; &#125; public void login()&#123; System.out.println(&quot;登陆：&quot; + name); System.out.println(company); //普通方法可以调用静态成员 &#125; public static void printCompany()&#123; login(); //调用非静态成员会报错 System.out.println(company); &#125; public static void main(String[] args)&#123; User u = new User(100,&quot;Tom&quot;); User.printCompany(); User.company = &quot;阿里&quot;; User.printCompany(); &#125;&#125; 静态初始化块构造方法用于对象的初始化。静态初始化块，用于类的初始化操作。在静态初始化块中不能直接访问非static成员。 静态初始化块执行顺序：1、上溯到Object类，先执行Object类的静态初始化块，再向下执行子类的静态初始化块，直到我们的类的静态初始化块为止。2、构造方法执行和上述方法一样。 1234567891011121314151617181920public class User&#123; int id; String name; String password; static String company; static&#123; System.out.println(&quot;执行静态初始化工作。&quot;); company = &quot;腾讯&quot;; printCompany(); &#125; public static void printCompany()&#123; System.out.println(&quot;company&quot;); &#125; public static void main(String[] args)&#123; User u = null; &#125;&#125; 参数传递机制Java中，方法的所有参数都是“值传递”，也就是说“传递的是值的副本”。我们得到的是“原参数的复印件”，而不是原件。因此，复印件不会改变原件。 传递的是值的副本。但是引用类型指的是“对象的地址”。因此副本和原参数都指向了同一个“地址”，改变“副本指向地址对象的值，也意味着原参数指向对象的值也发生了改变”。 1234567891011121314151617181920212223242526272829//多个变量指向同一个对象public class User&#123; int id; String name; String password; public User(int id, String name)&#123; this.id = id; this.name = name; &#125; public void testParameterTransfer1(User u)&#123; u.name = &quot;Tom&quot;; &#125; public void testParameterTransfer2(User u)&#123; u = new User(200, &quot;David&quot;); &#125; public static void main(String[] args)&#123; User u1 = new User(100, &quot;Alice&quot;); u1.testParameterTransfer1(u1); System.out.println(u1.name); //Tom u1.testParameterTransfer2(u1); System.out.println(u1.name); //依旧是Tom &#125;&#125; 包包机制是Java中管理类的重要手段。开发中，我们会遇到大量重名的类，通过包我们可以解决类重名的问题，也可以实现对类的有效管理。包对于类，相当于文件夹对于文件的作用。 通过package实现对类的管理，package的使用有两个要点：1、通常是类的第一句非注释性语句。2、包名：域名倒着写，再加上模块名便于管理。 123//package命名举例package com.sum.test;package com.oracle.test; 写项目时都要加包，不要使用默认包。 JDK中的主要包： import导入普通导入如果我们要使用其他包的类，需要使用import导入，从而可以在本类中直接同过类名调用，否则就要通过书写类的完整包名和类名。 要点：1、Java会默认导入java.lang包下所有的类因此这些类可以直接使用。2、如果导入两个重名的类，只能用包名+类名来显式调用相关类。 1234567891011import java.sql.Date;import java.util.*; //导入该包下所有的类，降低编译速度，不降低运行速度public class Test&#123; public static void main(String[] args)&#123; Date now1; //这里指java.sql.Date java.util.Date now2 = new java.util.Data(); //java.util.Date和java.sql.Date重名，需要完整路径 System.out.pringln(&quot;now2&quot;); Scanner input = new Scanner(System.in); //非同名类不需要完整路径 &#125;&#125; 静态导入静态导入用于导入指定类的静态属性，这样我们可以直接使用静态属性。 12345678910package test;import static java.lang.Math.* //导入Math类的所有静态属性import static java.lang.Math.PI; //导入Math类的PI属性public class Test&#123; public static void main(String[] args)&#123; System.out.println(PI); System.out.println(random()); &#125;&#125;]]></content>
      <categories>
        <category>Java知识体系</category>
      </categories>
      <tags>
        <tag>Java知识体系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础语法]]></title>
    <url>%2F2019%2F04%2F16%2FJava%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[注释单行注释：使用 “//“ 开头，后面的单行内容为注释。 多行注释：以 “/“ 开头， “/“ 结尾，中间内容为注释，不能嵌套使用。 文档注释：以 “/*“ 开头， “/“ 结尾，包含说明性的文字及一些JavaDoc标签，写项目时可以生成项目API。 标识符使用规范表示类名的标识符：每个单词首字母大写，如BallGame、Player。。 表示方法和变量的标识符：满足“驼峰规则”，如eat(),eatFood()。 Java关键字和保留字 变量声明变量12double salary;int age; 变量类型可以是基本类型，也可以是引用类型。 变量分类 类型 声明位置 从属于 生命周期 局部变量 方法或语句块内部 方法/语句块 从声明位置开始，直到方法或语句块执行完毕，局部变量消失 成员变量（实例变量） 类内部，方法外部 对象 创建对象，成员变量也跟着创建，对象消失，成员变量也跟着消失 静态变量（类变量） 类内部，static修饰 类 类被加载，静态变量就有效，类被卸载，静态变量就消失 整型数据类型 类型 占用存储空间 byte 1字节 short 2字节 int 4字节 long 8字节 特殊进制表示方法： 八进制整数：以0开头，如：013十六进制数：以0x或0X开头，如：0x15二进制数：以0b或0B开头，如0b011001011 浮点型数据 类型 占用存储空间 float 4字节 double 8字节 浮点数和整数的比较java.math包下有两个类：BigInteger和BigDecimal,这两个类可以处理任意长度的数值。BigInteger实现了任意精度的整数运算。BigDecimal实现了任意精度的浮点运算。 12345678910111213BigDecimal bd = BigDecimal.valueOf(1.0); //bd = 1.0bd = bd.substract(BigDecimal.valueOf(0.1));bd = bd.substract(BigDecimal.valueOf(0.1));bd = bd.substract(BigDecimal.valueOf(0.1));bd = bd.substract(BigDecimal.valueOf(0.1));bd = bd.substract(BigDecimal.valueOf(0.1)); //bd减0.1System.out.println(bd);System.out.println(1.0 - 0.1 - 0.1 - 0.1 - 0.1 - 0.1); //0.50000000000000001 有误差BigDecimal bd1 = BigDecimal.valueOf(0.1);BigDecimal bd2 = BigDecimal.valueOf(1.0/10.0);System.out.println(bd1.equals(bd2)); //true 字符型数据char类型用来表示在Unicode的编码表中的字符。Unicode编码被设计用来处理各种语言的文字，占两个字节。 Unicode具有从0到65535之间的编码，通常用从’\u0000’到’\uFFFF’之间的十六进制值来表示。 转义字符： 转义符 含义 Unicode值 \b 退格（backspace） \u0008 \n 换行 \u000a \r 回车 \u000d \t 制表符（tab） \u0009 \” 双引号 \u0022 \’ 单引号 \u0027 \\ 反斜杠 \u005c boolean类型数据boolean类型有两个常量值，true和false，在内存中占一位（不是一个字节），不可以使用0或非0的整数替代。 运算符二元运算符Java中二元运算符与C中大同小异，包含：’+’ ‘-‘ ‘*’ ‘/‘ ‘%’。 运算规则： ·如果两个操作数有一个为long，结果为long。·没有long时，结果为int，即使操作数全为short，byte，结果也是int。·如果两个操作数有double，结果为double。·只有两个操作数都是float，结果才为float。·求余运算，余数符号与左边操作数相同，如：7 % 3 = 1，-7 % 3 = -1，7 % (-3) = 1。 一元运算符包含 ‘++’,’–’,用法与C相同。 赋值运算符和扩展赋值运算符 关系运算符 位运算符 1234int a = 3 * 2 * 2;int b = 3 &lt;&lt; 2; //相当于3 * (2^2)int c = 12 / (2^2);int d = 12 &gt;&gt; 2;//相当于12/2/2 条件运算符语法格式：1x ? y : z; 1234int a = 14;int b = 10;int max;max = a &gt; b ? a : b; 自动类型转换自动类型转换只容量小的数据类型可以自动转换成容量打的数据类型。 实线表示无数据丢失的自动类型转换，虚线表示转换时可能会有精度的损失。 强制类型转换在变量前用括号指定类型。1(type)var; 12double x = 3.14;int nx = (int)x; //值为3 使用Scanner获得键盘输入12345678910111213import java.util.Scanner; 导入包public class TextScanner&#123; public static void main(String[] args)&#123; Scanner scanner = new scanner(System.in); System.out.println(&quot;请输入名字:&quot;); String name = Scanner.nextLine(); System.out.println(&quot;请输入爱好：&quot;); String favor = Scanner.nextLine(); System.out.println(&quot;请输入年龄：&quot;); int age = Scanner.nextInt(); &#125;&#125; 选择结构语法结构：1234//if 单选择结构if(布尔表达式)&#123; 语句块&#125; 1234567// if else 双选择结构if(布尔表达式)&#123; 语句块&#125;else&#123; 语句块&#125; 12345678910111213// switch 多选择结构switch(表达式)&#123; case 值1: 语句序列1; break; case 值2: 语句序列2; break; …………………………………… default: 默认语句; break;&#125; 循环结构语法结构：1234// while循环while(布尔表达式)&#123; 语句块;&#125; 1234// do whiledo&#123; 语句块;&#125;while(布尔表达式); //分号不能省略 1234// for循环for(初始表达式;布尔表达式;；迭代因子)&#123; 语句块;&#125; 方法基本概念方法是一段用来完成特定功能的代码片段，类似于其他语言的函数。 方法的结构：123[修饰符1，修饰符2···] 返回值类型 方法名(形式参数列表)&#123; Java语句;&#125; 虚高东两个概念：·形式参数：在方法声明时用于接收外界传入的数据。·实参：调用方法时实际传给方法的数据。 12345678910111213public class method&#123; public static void main(String[] args)&#123; int n1 = 3; int n2 = 8; int sum = add(n1,n2); //n1,n2为实参 System.println(sum); &#125; public static int add(n1,n2)&#123; return n1+n2; &#125;&#125; 方法的重载(overload)方法的重载是指一个类中可以定义多个方法名相同，但参数不同的方法。调用时，会根据不同的参数自动匹配对应的方法。重载的方法只是名称相同而已，实际是完全不同的方法。 构成重载的条件：·不同的含义：形参类型，形参顺序，形参个数不同。·只有返回值不同不构成重载。如：1234567int a(String str)&#123; ···&#125;和void a(String str)&#123; ···&#125; 不构成重载。·只有形参的名称不同，不构成重载。 123456789101112131415161718public class method&#123; public static void main(String[] args)&#123; int n1 = 3; int n2 = 8; int sum = add(n1,n2); //n1,n2为实参 System.println(sum); &#125; public int add(n1,n2)&#123; return n1+n2; &#125; //方法重载 public int add(n1,n2,n3)&#123; return n1+n2+n3; &#125; &#125; 递归结构递归结构包括两个部分：·递归头：什么时候不调用自身方法。如果没有递归头，将陷入死循环，递归头是递归的结束条件。·递归体：什么时候需要调用自身方法。 12345678static long factorial(int n)&#123; if(n == 1)&#123; //递归头 return 1; &#125; else&#123; //递归体 return n*factorial(n-1); &#125;&#125; 注意事项：在高性能的情况下尽量避免使用递归，递归调用既花时间，又耗内存。]]></content>
      <categories>
        <category>Java知识体系</category>
      </categories>
      <tags>
        <tag>Java知识体系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Spring实战》笔记]]></title>
    <url>%2F2019%2F04%2F16%2FSpring%2F</url>
    <content type="text"><![CDATA[一·Spring之旅1.1 简化Java开发Spring是一个基于IOC和AOP的结构J2EE系统的框架。Spring是一个开源框架，可以使用该框架来简化Java开发，为了降低Java开发的复杂性，Spring采取了以下四种关键策略：·基于POJO的轻量级和最小入侵性编程。·通过依赖注入和面向接口实现松耦合。·基于切面和惯例进行声明式编程。·通过切面和模板减少样板式代码。 1.1.1 激发POJO的潜能首先介绍什么是POJO：“Plain Ordinary Java Object”即“简单的Java对象”。POJO的内在含义是指那些没有从任何类继承、也没有实现任何接口，更没有被其它框架侵入的java对象。例如： 12345public class HelloWorldBean &#123; public String sayHello &#123; return &quot;Hello World&quot;; &#125;&#125; 1.1.2 依赖注入（DI）什么是依赖？对象的关系一般有两种：is a ： 是一个， 继承关系。has a ：有一个， 成员变量，依赖关系。 123class A&#123; private B b; //A类依赖B类&#125; 依赖：一个对象使用另一个对象。注入：通过setter方法进行另一个对象实例设置。 依赖注入 Dependency Inject. 简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。 DI功能如何实现DI的目的是使对象的依赖关系降低。即降低耦合性。 123456789101112//紧耦合的代码public class DamselRescuingKnight implements Knight &#123; private RescueDamselQuest quest; public DamselRescuingKnight() &#123; this.quest = new RescueDamselQuest(); //在类中实例化了对象，耦合程度紧。 &#125; public void embarkOnQuest() &#123; quest.embark(); &#125;&#125; 紧耦合会使代码难以复用、难以测试、难以理解。 123456789101112//松耦合代码public class BraveKnight implements Knight &#123; private Quest quest; public BraveKnight(Quest quest) &#123; //构造器注入 this.quest = quest; &#125; public void embarkOnQuest() &#123; quest.embark(); &#125;&#125; BraveKnight没有与任何特定的Quest实现发声耦合，只要实现了Quest接口，具体使哪类的Quest无关紧要，提高了代码复用性。 如何工作Spring通过应用上下文装载bean的定义并把它们组织起来。 1.1.3 应用切面（AOP）面向切面编程，允许你将遍布应用各处的功能分离形成可用的组件。使服务模块化，确保POJO的简单性。 一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。 1.1.4 使用模板消除样板式代码样板式代码：为了实现通用的和简单的功能，不得不重复编写的代码。例如使用JDBC访问数据库查询数据。Spring旨在通过模板封装来消除样板式代码。 1.2容纳你的Bean在基于Spring的应用中，你的应用对象生存于Spring容器中。对象由Spring容器创建和装配，并存在于容器之中。容器是Spring框架的核心。Spring自带了多个容器的实现，可以归为两种不同的类型。1.Bean工厂。2.应用上下文。 1.2.1 使用应用上下文Spring自带多种类型的应用上下文，下面罗列两个： ClassPathXmlApplicationContext: 从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。12ApplicationContext context = new ClassPathXmlApplicationContext(&quot;文件路径.xml&quot;); //文件系统路径 FileSystemXmlApplicationContext:从文件系统下的一个或多个XML配置文件中加载上下文定义。12ApplicationContext context = new FileSystemXmlApplicationContext(&quot;文件名.xml&quot;); //类路径下查找 应用上下文准备就绪后，可以调用上下文的getBean()方法从Spring容器中获取bean。 1.2.2 bean的生命周期 1.3俯瞰Spring风景线Spring框架之内，关注与通过DI，AOP和消除样板式代码来简化企业级Java开发。但在Spring框架之外，还存在一个构建在核心框架之上的庞大生态圈，将Spring扩展到不同领域，例如Web服务、REST（一种针对网络应用的设计和开发方式）、移动开发以及NoSQL（非关系型数据库,如MongoDB）。 1.3.1 Spring模块 1.3.2 Spring Portfoliospring protfolio几乎为每一个领域的java开发提供了编程模型：1.Spring Web Flow2.Spring Web Service3.Spring Security4.Spring Integretion5.Spring Batch6.Spring Data7.Spring Social8.Spring Mobile9.Spring for Android10.Spring boot 1.4 Spring的新功能不讲。 二·装配BeanSpring中装配bean有多种方式，先介绍配置Spring容器最常见三种方法。 2.1 Spring配置的可选方案Spring提供了主要的装配机制：·在XML中进行显示配置；·在Java中进行显示配置；·隐式的bean发现机制和自动装配。 建议尽可能地使用自动装配机制，显示配置越少越好。其次时JavaConfig。最后考虑XML。 2.2 自动化装配beanSpring从两个角度来实现自动化装配：·组件扫描：Spring会自动发现应用上下文中所创建的bean。·自动装配：Spring自动满足bean之间的依赖。 2.2.1 创建可被发现的bean首先以CD来阐述DI如何运行：如果你不将CD插入（注入）到CD播放器中，那么CD播放器没有什么太大的用处。所以，CD播放器依赖于CD才能完成他的使命。 首先，在Java中建立CD的概念： 123456//定义CD的一个接口package soundsystem;public interface CompactDisc&#123; void play();&#125; 作为接口，它定义了CD播放器对一盘CD所能进行的操作。它将CD播放器的任意实现与CD本身的耦合降低到最小程度。 我们还需要一个CompactDisc的实现： 12345678910111213//带有@Component注解的CompactDisc实现类SgtPepperspackage soundsystem;import org.springframework.stereotype.Component;@Componentpublic class SgtPeppers implements CompactDisc&#123; //implements是实现一个接口用的关键字 private String title = &quot;Sgt.Pepper&apos;s Lonely Hearts Club Band&quot;; private String artist = &quot;The Beatles&quot;; public void play()&#123; System.out.println(&quot;Playing &quot;+ title + &quot;by &quot; + artist); &#125;&#125; SgtPeppers类上使用了@Component注解，这个注解表明该类会作为组件类，并告知Spring要为这个类创建Bean。不过，组件扫描默认是不启动的，还需要显示配置Spring，命令它区寻找带有@Component注解的类，并为其创建Bean。 123456789//@ComponentScan注解启用了组件扫描package soundsystem;import org.springframework.context.annotation.componentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScanpublic class CDPlayerConfig&#123;&#125; 类CDPlayerConfig通过Java代码定义了Spring的装配规则。CDPlayerConfig类并没有显式地声明任何bean，只不过它使用了@ComponentScan注解，这个注解能够在Spring中启用组件扫描。 1234567891011121314151617181920//测试组件扫描能够发现CompactDiscpackage soundsystem;import static org.junit.Assert.*;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.text.context.junit4.Spring.JUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class) //自动创建@ContextConfiguration(classes=CDPlayerConfig.class) //加载配置public class CDPlayerTest&#123; @Autowired private CompactDisc cd; @Test public void cdShouldNotBeNull()&#123; //断言cd属性不为空 assertNotNull(cd); &#125;&#125; CDPlayerTest使用Spring的SpringJUnit4ClassRunner，以便在测试开始的时候自动创建Spring的应用上下文。注解@ContextConfiguration会告诉它需要在CDPlayerConfig中加载配置。因为CDPlayerConfig类里包含了@ComponentScan，因此最终的应用上下文中应该包含CompactDisc bean。 2.2.2 为组件扫描的bean命名Spring应用上下文中所有的bean都会有一个ID，尽管我们没有给SgtPeppers bean设置ID，但Spring会给它设置为sgtPeppers，即首字母小写。 @Component注解设置ID1234@Component(&quot;lonelyHeartsClub&quot;) //将ID设为lonelyHeartsClubpublic class SgtPeppers implements CompactDisc&#123; ···&#125; @Named注解设置ID1234567package soundSystem;import javax.inject.Named;@Named(&quot;LonelyHeartsClub&quot;)public class SgtPeppers implements CompactDisc&#123; ···&#125; 推荐使用@Component注解来设置ID。 2.2.3 设置组件扫描基础包我们没有为@ComponentScan设置任何属性，按照默认规则，它会以配置类所在的包作为基础来扫描组件。而如果我们想将配置类放在一个包中，我们就要明确的设置基础包。 1234//@ComponentScan的value属性中指明包的名称@configuration@ComponentScan(&quot;soundSystem&quot;)public class CDPlayerConfig&#123;&#125; 1234//通过basePackages属性来强调配置基础包@configuration@ComponentScan(basePackages = &quot;soundSystem&quot;,&quot;vidio&quot;) //可以配置多个包public class CDPlayerConfig&#123;&#125; 上述例子中所配置的包是以String类型表示的但如果重构代码，所指定的基础包可能会出错。 1234//将其指定为包中所包含的类或接口@Configuration@ComponentScan(basePackageClasses = &#123;CDPlayer.class, DVDPlayer.class&#125;) //这些类所在包会作为组件扫描基础包public class CDPlayerConfig&#123;&#125;; 2.2.4 通过为bean添加注解实现自动装配自动装配就是让Spring自动满足bean依赖的一种方法，在满足依赖的过程中，会在Spring的应用上下文中寻找匹配某个bean需求的其他bean。 123456789101112131415161718在构造器中使用@Aotowired注解package soundSystem;import org.springframework.beans.factory.annotation.Aotowired;import org.springfranework.setereotype.Component;@Componentpublic class CDPlayer implements MediaPlayer&#123; private CompactDisc cd; @Aotowired //当Spring创建CDPlayer bean的时候，会通过构造器实例化，并传入一个可设置给CompactDisc类型的bean public CDPlayer(CompactDisc cd)&#123; this.cd = cd; &#125; public void play()&#123; cd.play(); &#125;&#125; 12345//在属性的Setter方法上使用@Aotowired@Aotowiredpublic void setCompactDisc(CompactDisc cd)&#123; this.cd = cd;&#125; @Aotowired注解可以用在类的任何方法上。Spring会尝试满足方法参数上声明的依赖。 如果没有匹配的bean在应用上下文创建的时候，Spring会抛出一个异常。可以将@Aotowired的required属性设置为false 1@Aotowired(required = false) 在自动装配中，Spring同时支持@Aotowired注解和@Inject注解。@Inject是Java依赖注入规范，大多数场景可以互相替换。 2.2.5 验证自动装配]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 1]]></title>
    <url>%2F2019%2F02%2F24%2FLeetcode-1%2F</url>
    <content type="text"><![CDATA[题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] C代码123456789101112131415int* twoSum(int* nums, int numsSize, int target) &#123; int i,j; static int a[2]; for(i = 0; i &lt; numsSize; i++)&#123; for(j = i +1; j &lt; numsSize; j++)&#123; if(nums[i] + nums[j] == target)&#123; a[0] = i; a[1] = j; return a; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建较长的宏]]></title>
    <url>%2F2019%2F01%2F28%2F%E5%88%9B%E5%BB%BA%E8%BE%83%E9%95%BF%E7%9A%84%E5%AE%8F%2F</url>
    <content type="text"><![CDATA[逗号运算符C语言中，“，”是一种运算符，成为逗号运算符。可以将许多表达式连接起来组成一个表达式，一般形式：表达式1，表达式2，表达式3······其求值是分别求两个表达式的值，并以最后的表达式的值作为整个逗号表达式的值。应用举例：12345678#include&lt;stdio.h&gt;int main()&#123; int a = 2,b = 3,c = 4; int x,y; y = ( (x = a + b) , b + c ); printf(&quot;x = %d, y = %d&quot;,x,y); return 0;&#125; 运行结果：x = 5, y = 7 创建较长的宏创建较长的宏时，逗号运算符会十分有用。例如：1#define ECHO(s) (gets(s),puts(s)) 如果不想使用逗号运算符，可以将函数放在花括号中形成复合语句:1#define ECHO(s) &#123; gets(s) ; puts(s) ;&#125; 但是这样在调用时也许会发生这样的情况：1234if (flag) ECHO(s);else gets(str); 这里ECHO后面的分号会使else没有配对。解决方法是将语句放在do循环中：12345#define ECHO(s) \ do&#123; \ gets(s);\ puts(s);\ &#125;while(0) 这样，调用时就是这种情况：1ECHO(str) \*do&#123; gets(str); puts(str); &#125;while(0); *\ 参考《C语言程序设计·现代方法》]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ALL in ALL]]></title>
    <url>%2F2019%2F01%2F17%2FALL-in-ALL%2F</url>
    <content type="text"><![CDATA[题目描述两个字符串s和t，判断是是否为t的子序列。 输入包括若干个测试数据，结束由EOF结束。 输出对每个测试数据，是子序列输出Yes,否则输出No。 样例输入sequence subsequenceperson compressionVERDI vivaVittorioEmanueleReDiItaliacaseDoesMatter CaseDoesMatter 样例输出YesNoYesNo 代码123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int solve(char *s ,char *t);#define maxn 110000char s[maxn],t[maxn];int main(int argc, char *argv[]) &#123; while( scanf(&quot;%s%s&quot;,s,t) != EOF )/*scamf以%s格式输入时，空格、换行符、TAB等是作为两个数据的分隔符存在的，即分隔符前后是两个数据，读入时分隔符不读如。*/ printf(&quot;%s\n&quot;,solve(s,t)?&quot;Yes&quot;:&quot;No&quot;); return 0;&#125;int solve(char *s ,char *t)&#123; int i,j,slen,tlen; slen = strlen(s); tlen = strlen(t); for(i = 0,j = 0; i &lt; slen &amp;&amp; j &lt; tlen;)&#123; if(s[i] == t[j])&#123; i++; j++; &#125; else j++; &#125; return i == slen;//判断是否将s字符串判断完。&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异或实现两数交换]]></title>
    <url>%2F2019%2F01%2F06%2F%E5%BC%82%E6%88%96%E5%AE%9E%E7%8E%B0%E4%B8%A4%E6%95%B0%E4%BA%A4%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[异或运算的概念定义：判断两个值是否不同，两个值相同时，返回false；两个值不同时，返回ture。 异或运用两数交换1.异或运算有个特点：对一个值连续做两次异或运算，会返回值本身。( x ^ y ) ^ y = x ^ 0 = x2.对于任何数x，都有x^x=0,x^0=x。3.交换律。4.结合律(a^b)^c == a^(b^c)。 利用如上性质，就可以实现不用引入中间变量而交换两个变量的值，节约储存空间。 1234int a,b;a = a ^ b;b = b ^ a;a = a ^ b; 两数最大值或最小值12min = (y ^ (x ^ y) &amp; - (x &lt; y) ) //最小值max = (x ^ (x ^ y) &amp; - (x &lt; y) ) //最大值]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[质数判定]]></title>
    <url>%2F2019%2F01%2F06%2F%E8%B4%A8%E6%95%B0%E5%88%A4%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[一·初等算法(试除法)用 n 除以从 2 ～ n^½ 的各个数，没有一个能够整除，即为质数。 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;math.h&gt;int isPrime(int n)&#123; int i; int flag = 1; scanf(&quot;%d&quot;,&amp;n); for(i = 2; i &lt;= sqrt(n); i++) &#123; if( n % i == 0 ) &#123; flag = 0; break; &#125; else continue; &#125; if(flag) return 1; else return 0;&#125; 二·初等算法改进篇判断2之后，直接判断从3到n^½的各个奇数，质数是不能被2整除的（查质数表一目了然，不再赘述）。 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;math.h&gt;int isPrime(int n)&#123; int i; int flag = 1; scanf(&quot;%d&quot;,&amp;n); if( n % 2 == 0 ) return 0; else &#123; for(i = 3; i &lt;= sqrt(n); i += 2) &#123; if( n % i == 0 ) &#123; flag = 0; break; &#125; else continue; &#125; &#125; if(flag) return 1; else return 0;&#125; 三·相邻法原理：大于等于5的质数一定和6的倍数相邻。 大于5的各个数用x表示：6x-1 6x 6x+1 6x+2 6x+3 6x+4 6x+5 6(x+1)其中，除了6x-1，6x+1和6x+5以外，其余的数都能够被2或3整除。 int isPrime(int n) { int i; if(n == 2 || n == 3 || n == 5) //筛去6以下的质数 return 1; if(n % 6 != 1 &amp;&amp; n % 6 != 5) //筛去没有与6相邻的数 return 0; for(i = 5; i &lt;=sqrt(n); i += 6) { if(n % i == 0 || n % (i+2) == 0) //筛去能被小的与6相邻数整除的数。 return 0; } return 1; } 实际使用起来前两个方法更加普遍，但效率较低，可以根据实际需求自行选择。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
